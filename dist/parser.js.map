{"version":3,"sources":["../lib/parser.ts"],"sourcesContent":["// parser.ts — Advanced syntax analyzer that converts tokens\n//             into AST with customizable grammar rules and intelligent error detection.\n//\n// repo   : https://github.com/je-es/parser\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔═══════════════════════════════════════════ TYPE ════════════════════════════════════════════╗\n\n    // Represents a span in the source text\n    export interface Span {\n        start           : number;\n        end             : number;\n    }\n\n    // Represents a token with type, value and position information\n    export interface Token {\n        type            : string;\n        value           : string | null;\n        span            : Span;\n    }\n\n    // Represents a pattern in the grammar\n    export interface Pattern {\n        type            : 'token' | 'rule' | 'repeat' | 'choice' | 'seq';\n        [key: string]   : any;\n        silent          : boolean; // Fixed typo: scilent -> silent\n    }\n\n    // Represents an error handler\n    export interface ErrorHandler {\n        cond            : number | ((parser: Parser, failedAt: number, force?: boolean) => boolean);\n        msg             : string;\n        code           ?: number;\n    }\n\n    // Represents a recovery strategy\n    export interface RecoveryStrategy {\n        type            : 'panic' | 'skipUntil';\n        tokens         ?: string[];\n        token          ?: string;\n    }\n\n    // Represents a rule in the grammar\n    export interface Rule {\n        name            : string;\n        pattern         : Pattern;\n\n        options        ?: {\n            build      ?: (matches: any[]) => any;\n            errors     ?: ErrorHandler[];\n            recovery   ?: RecoveryStrategy;\n            ignored    ?: string[];\n            silent     ?: boolean; // Rule-level silent mode\n        };\n    }\n\n    // Represents a list of rules\n    export type Rules = Rule[];\n\n    // Represents a parse statistics\n    export interface ParseStatistics {\n        tokensProcessed : number;\n        rulesApplied    : number;\n        errorsRecovered : number;\n        parseTimeMs     : number;\n    }\n\n    // Represents an AST node\n    export type BaseAstNode = {\n        rule            : string;\n        span            : Span;\n        value          ?: string | number | boolean | null;\n    }\n\n    // With this we can customize the AST for the next stages\n    // depending on your needs\n    export type AstNode = BaseAstNode | any;\n\n    export interface ParseError {\n        msg             : string;\n        code            : number;\n        span            : Span;\n    }\n\n    // Represents a parse result\n    export interface ParseResult {\n        ast             : AstNode[];\n        errors          : ParseError[];\n        statistics     ?: ParseStatistics;\n    }\n\n    // Represents a debug level\n    export type DebugLevel = 'off' | 'errors' | 'rules' | 'patterns' | 'tokens' | 'verbose';\n\n    // Represents a parser settings\n    export interface ParserSettings {\n        startRule       : string;\n        errorRecovery  ?: {\n            mode       ?: 'strict' | 'resilient';\n            maxErrors  ?: number;\n            syncTokens ?: string[];\n        };\n        ignored        ?: string[];\n        debug          ?: DebugLevel;\n        maxDepth       ?: number;\n        maxCacheSize   ?: number; // in megabytes\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔═══════════════════════════════════════════ CORE ════════════════════════════════════════════╗\n\n    /**\n     * Parser class for advanced syntax analysis.\n     * Parses tokens into AST with customizable grammar rules and intelligent error detection.\n     * @class\n    */\n    export class Parser {\n\n        // ┌─────────────────────────────── DATA ───────────────────────────────┐\n\n            // ..\n            public rules            : Map<string, Rule>;\n            public settings         : ParserSettings;\n\n            // ..\n            public tokens           : Token[]               = [];\n            public ast              : AstNode[]             = [];\n            public errors           : ParseError[]          = [];\n\n            // ..\n            public index            : number                = 0;\n            public depth            : number                = 0;\n\n            // Debug system\n            private debugLevel      : DebugLevel;\n            private indentLevel     : number                = 0;\n\n            // Statistics\n            public stats            : ParseStatistics;\n            public startTime        : number                = 0;\n            public errorSeq         : number                = 0;\n\n            // Performance optimizations\n            public memoCache        : Map<string, any>      = new Map<string, any>();\n            public ignoredSet       : Set<string>           = new Set<string>();\n\n            // Memoization statistics\n            public memoHits         : number                = 0;\n            public memoMisses       : number                = 0;\n\n            // Silent mode context stack - tracks when we're in silent parsing\n            private silentContextStack : boolean[]          = [];\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── INIT ───────────────────────────────┐\n\n            constructor(rules: Rule[], settings?: ParserSettings) {\n                // set => rules\n                this.rules = new Map();\n                rules.forEach(rule => this.rules.set(rule.name, rule));\n\n                // set => settings\n                this.settings = this.normalizeSettings(settings);\n\n                // set => debug\n                this.debugLevel = this.settings.debug!;\n\n                // set => ignored\n                this.ignoredSet = new Set([...this.settings.ignored!]);\n\n                // set => stats\n                this.stats = {\n                    tokensProcessed     : 0,\n                    rulesApplied        : 0,\n                    errorsRecovered     : 0,\n                    parseTimeMs         : 0\n                };\n\n                // Validate grammar\n                const grammarIssues = this.validateGrammar();\n                if (grammarIssues.length > 0) {\n                    throw new Error(`Grammar validation failed: ${grammarIssues.join(', ')}`);\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── MAIN ───────────────────────────────┐\n\n            /**\n             * Parses the given tokens using the defined rules and returns the AST and errors.\n             *\n             * @param {Token[]} tokens - The tokens to parse.\n             *\n             * @return {ParseResult} The AST and errors generated during parsing.\n            */\n            parse(tokens: Token[]): ParseResult {\n                // Before\n                {\n                    this.resetState(tokens);\n                    this.startTime = Date.now();\n                    this.log('rules', `🚀 Parse started: ${tokens.length} tokens`);\n                }\n\n                // Early Break\n                {\n                    // check tokens length\n                    if (!tokens?.length) { return { ast: [], errors: [] }; }\n\n                    // check if tokens contains error tokens\n                    if(tokens.some(token => token.type === 'error')) {\n                        const errorToken = tokens.find(token => token.type === 'error');\n                        return {\n                            ast     : [],\n                            errors  : [this.createError(0x000, `Unexpected token '${errorToken?.value}'`, errorToken?.span)]\n                        };\n                    }\n                }\n\n                // Parse\n                {\n                    try {\n                        // Get start rule\n                        const startRule = this.rules.get(this.settings.startRule);\n                        if (!startRule) {\n                            throw new Error(`Start rule '${this.settings.startRule}' not found`);\n                        }\n\n                        // Skip ignored tokens\n                        this.skipIgnored();\n\n                        // Parse with error recovery\n                        this.parseWithRecovery(startRule);\n\n                        // Skip ignored tokens\n                        this.skipIgnored();\n                    }\n\n                    catch (err: any) {\n                        this.handleFatalError(err);\n                    }\n                }\n\n                // After\n                {\n                    this.stats.parseTimeMs = Date.now() - this.startTime;\n                    this.log('rules', `✅ Parse completed: ${this.ast.length} nodes, ${this.errors.length} errors (${this.stats.parseTimeMs}ms)`);\n                    this.log('verbose', `📊 Memo stats: ${this.memoHits} hits, ${this.memoMisses} misses, ${this.memoCache.size} cached entries`);\n\n                    return {\n                        ast: this.ast,\n                        errors: this.errors,\n                        statistics: this.stats\n                    };\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── CORE ───────────────────────────────┐\n\n            private parseWithRecovery(startRule: Rule): void {\n                const maxErrors = this.settings.errorRecovery!.maxErrors!;\n                let consecutiveErrors = 0;\n\n                while (this.index < this.tokens.length && (maxErrors === 0 || this.errors.length < maxErrors)) {\n                    const beforeIndex = this.index;\n\n                    try {\n                        // Parse start rule\n                        const result = this.parsePattern(startRule.pattern, startRule);\n\n                        // Build AST node\n                        if (result !== null) {\n                            const processed = startRule.options?.build\n                                ? this.safeBuild(startRule.options.build, result)\n                                : result;\n\n                            if (processed !== null) {\n                                this.ast.push(processed);\n                            }\n                        }\n\n                        // Reset consecutive error counter on success\n                        consecutiveErrors = 0;\n\n                        // Break if we've consumed all tokens or no progress\n                        if (this.index >= this.tokens.length || this.index === beforeIndex) {\n                            break;\n                        }\n                    }\n                    catch (error: any) {\n                        consecutiveErrors++;\n\n                        // Convert to ParseError and add to errors\n                        const parseError = this.normalizeError(error, this.getCurrentSpan());\n                        this.addError(parseError);\n\n                        // Apply recovery strategy\n                        this.applyRecovery(startRule, beforeIndex);\n\n                        // Prevent infinite loops\n                        if (consecutiveErrors > 10 || this.index === beforeIndex) {\n                            if (this.index < this.tokens.length) {\n                                this.index++;\n                            } else {\n                                break;\n                            }\n                        }\n\n                        // In strict mode, stop after first error\n                        if (this.settings.errorRecovery!.mode === 'strict') {\n                            break;\n                        }\n                    }\n\n                    // Skip ignored tokens\n                    this.skipIgnored();\n                }\n            }\n\n            protected parsePattern(pattern: Pattern, parentRule?: Rule): any {\n                // Check depth\n                if (this.depth > this.settings.maxDepth!) {\n                    throw new Error('Maximum parsing depth exceeded');\n                }\n\n                // Determine if this pattern should be silent\n                const shouldBeSilent = this.shouldBeSilent(pattern, parentRule);\n\n                // Push silent context\n                this.silentContextStack.push(shouldBeSilent);\n\n                // Save current data\n                const startIndex = this.index;\n\n                // Create memoization key\n                const memoKey = this.createMemoKey(pattern.type, pattern, startIndex, parentRule?.name);\n\n                // Check memo cache - but be more selective about when to use it\n                let memoResult: { hit: boolean; result?: any; newIndex?: number } = { hit: false };\n\n                // Only use memoization for certain pattern types and when not in error recovery\n                const shouldUseMemo = this.shouldUseMemoization(pattern, parentRule);\n\n                if (shouldUseMemo) {\n                    memoResult = this.getMemoized(memoKey);\n                    if (memoResult.hit) {\n                        this.index = memoResult.newIndex!;\n                        this.silentContextStack.pop();\n                        return memoResult.result;\n                    }\n                }\n\n                // Update depth\n                this.indentLevel++;\n                this.log('patterns', `${'  '.repeat(this.indentLevel)}➤ ${pattern.type}${parentRule ? ` (${parentRule.name})` : ''}${shouldBeSilent ? ' [SILENT]' : ''} @${this.index}`);\n                this.depth++;\n\n                // Parse pattern\n                let result: any = null;\n\n                try {\n                    // Skip ignored tokens\n                    this.skipIgnored(parentRule?.options?.ignored);\n\n                    // Pass to pattern handler\n                    switch (pattern.type) {\n                        case 'token':\n                            result = this.parseToken(pattern.name, parentRule, shouldBeSilent);\n                            break;\n                        case 'rule':\n                            result = this.parseRule(pattern.name, parentRule, shouldBeSilent);\n                            break;\n                        case 'repeat':\n                            result = this.parseRepeat(pattern.pattern, pattern.min || 0, pattern.max || Infinity, pattern.separator, parentRule, shouldBeSilent);\n                            break;\n                        case 'seq':\n                            result = this.parseSequence(pattern.patterns, parentRule, shouldBeSilent);\n                            break;\n                        case 'choice':\n                            result = this.parseChoice(pattern.patterns, parentRule, shouldBeSilent);\n                            break;\n                        default:\n                            throw new Error(`Unknown pattern type: ${(pattern as any).type}`);\n                    }\n\n                    // Log\n                    const status = result !== null ? '✓' : '✗';\n                    this.log('patterns', `${'  '.repeat(this.indentLevel)}${status} ${pattern.type} → ${this.index}`);\n\n                    // Memoize result (with conditions)\n                    if (shouldUseMemo) {\n                        this.memoize(memoKey, result, startIndex, this.index);\n                    }\n\n                    // Return result\n                    return result;\n                }\n                finally {\n                    this.depth--;\n                    this.indentLevel--;\n                    this.silentContextStack.pop();\n                }\n            }\n\n            private parseToken(tokenName: string, parentRule?: Rule, shouldBeSilent?: boolean): Token | null {\n                this.log('tokens', `→ ${tokenName} @${this.index}`);\n\n                // EOF check\n                if (this.index >= this.tokens.length) {\n                    this.log('tokens', `✗ Expected '${tokenName}', got 'EOF' @${this.index}`);\n\n                    if (shouldBeSilent || this.isInSilentMode()) {\n                        return null;\n                    }\n\n                    const error = this.createError(0x001, `Expected '${tokenName}', got 'EOF'`, this.getCurrentSpan());\n                    this.handleParseError(error, parentRule, 0);\n                }\n\n                // Get current token\n                const token = this.getCurrentToken();\n\n                // Token matches - consume it\n                if (token.type === tokenName) {\n                    const consumedToken = { ...token };\n                    this.index++;\n                    this.stats.tokensProcessed++;\n\n                    this.log('tokens', `✓ ${tokenName} = \"${token.value}\" @${this.index - 1}`);\n                    return consumedToken;\n                }\n\n                // Token doesn't match\n                this.log('tokens', `✗ Expected '${tokenName}', got '${token.type}' @${this.index}`);\n\n                if (shouldBeSilent || this.isInSilentMode()) {\n                    return null;\n                }\n\n                const error = this.createError(0x002, `Expected '${tokenName}', got '${token.type}'`, this.getCurrentSpan());\n                this.handleParseError(error, parentRule, 0);\n            }\n\n            protected parseRule(ruleName: string, parentRule?: Rule, shouldBeSilent?: boolean): any {\n                this.log('rules', `→ ${ruleName} @${this.index}`);\n\n                // Get the target rule by name\n                const targetRule = this.rules.get(ruleName);\n                if (!targetRule) {\n                    const error = new Error(`Rule '${ruleName}' not found`);\n                    this.handleFatalError(error);\n                    return null;\n                }\n\n                // Save current position for potential rollback\n                const startIndex = this.index;\n                const savedErrors = [...this.errors];\n\n                try {\n                    // Stats\n                    this.stats.rulesApplied++;\n\n                    // Parse the target rule's pattern\n                    const result = this.parsePattern(targetRule.pattern, targetRule);\n\n                    // Handle null result\n                    if (result === null) {\n                        if (shouldBeSilent || this.isInSilentMode()) {\n                            this.log('rules', `✗ ${ruleName} (silent) @${this.index}`);\n                            return null;\n                        }\n\n                        // Create error for failed rule\n                        const error = this.createError(0x003, `Rule '${ruleName}' failed to match`, this.getCurrentSpan());\n                        this.handleParseError(error, parentRule, 0);\n                    }\n\n                    // Apply build function if available\n                    let finalResult = result;\n                    if (result !== null && targetRule.options?.build) {\n                        finalResult = this.safeBuild(targetRule.options.build, result);\n                    }\n\n                    this.log('rules', `✓ ${ruleName} @${this.index}`);\n                    return finalResult;\n\n                } catch (e) {\n                    // Rollback on error in silent mode\n                    if (shouldBeSilent || this.isInSilentMode()) {\n                        this.index = startIndex;\n                        this.errors = savedErrors;\n                        return null;\n                    }\n\n                    // Re-throw for error handling\n                    if(e instanceof Error) {\n                        this.handleFatalError(e);\n                    } else {\n                        const error = this.createError((e as ParseError).code, (e as ParseError).msg, (e as ParseError).span);\n                        this.handleParseError(error, parentRule, 0);\n                    }\n                }\n            }\n\n            private parseRepeat(pattern: Pattern, min = 0, max = Infinity, separator?: Pattern, parentRule?: Rule, shouldBeSilent?: boolean): any {\n                this.log('verbose', `REPEAT(${min}-${max}) @${this.index}`);\n\n                const results: any[] = [];\n                const startIndex = this.index;\n\n                // Parse pattern iterations\n                while (results.length < max && this.index < this.tokens.length) {\n                    const iterationStart = this.index;\n                    const savedErrors = [...this.errors];\n\n                    try {\n                        // Parse the main pattern\n                        const result = this.parsePattern(pattern, parentRule);\n\n                        // Pattern failed\n                        if (result === null) {\n                            // Restore errors state\n                            this.errors = savedErrors;\n\n                            // Break if we can't recover or we're in silent/strict mode\n                            if (shouldBeSilent || this.isInSilentMode() || pattern.silent ||\n                                this.settings.errorRecovery!.mode === 'strict') {\n                                break;\n                            }\n\n                            // Attempt recovery\n                            this.applyRecovery(parentRule, iterationStart);\n                            if (this.index === iterationStart) {\n                                break; // Recovery failed, avoid infinite loop\n                            }\n                            continue;\n                        }\n\n                        // Pattern succeeded\n                        results.push(result);\n\n                        // Prevent infinite loop\n                        if (this.index === iterationStart) {\n                            this.log('verbose', `⚠ No progress in repeat, breaking @${this.index}`);\n                            break;\n                        }\n\n                        // Handle separator (only between elements, not after the last one)\n                        if (separator && results.length < max && this.index < this.tokens.length) {\n                            const sepStart = this.index;\n                            const sepSavedErrors = [...this.errors];\n\n                            // Parse separator in silent mode first to check availability\n                            const sepResult = this.parsePattern(separator, undefined);\n\n                            if (sepResult === null) {\n                                // Separator not found - this is the end of the repetition\n                                this.index = sepStart;\n                                this.errors = sepSavedErrors;\n                                break;\n                            }\n                            // Separator found - continue with next iteration\n                        } else if (separator && results.length >= max) {\n                            // We've reached max items, no more separators needed\n                            break;\n                        }\n\n                    } catch (e) {\n                        // Restore state\n                        this.index = iterationStart;\n                        this.errors = savedErrors;\n\n                        // Handle error based on mode\n                        if (shouldBeSilent || this.isInSilentMode()) {\n                            break;\n                        }\n\n                        // In strict mode or if we haven't met minimum, this is a fatal error\n                        if (this.settings.errorRecovery!.mode === 'strict' || results.length < min) {\n                            if(e instanceof Error) {\n                                this.handleFatalError(e);\n                            } else {\n                                const error = this.createError((e as ParseError).code, (e as ParseError).msg, (e as ParseError).span);\n                                this.handleParseError(error, parentRule, 0);\n                            }\n                        }\n\n                        // Try recovery\n                        this.applyRecovery(parentRule, iterationStart);\n                        if (this.index === iterationStart) {\n                            this.index++; // Force progress\n                        }\n                    }\n                }\n\n                // Check minimum requirement\n                if (results.length < min) {\n                    const error = this.createError(\n                        0x005,\n                        `Expected at least ${min} occurrences, got ${results.length}`,\n                        this.getCurrentSpan()\n                    );\n\n                    if (shouldBeSilent || this.isInSilentMode()) {\n                        return null;\n                    }\n\n                    this.handleParseError(error, parentRule, 0);\n                }\n\n                this.log('verbose', `REPEAT → [${results.length}] @${this.index}`);\n                return results.length > 0 ? results : null;\n            }\n\n            private parseChoice(patterns: Pattern[], parentRule?: Rule, shouldBeSilent?: boolean): any {\n                this.log('verbose', `CHOICE[${patterns.length}] @${this.index}`);\n\n                const startPosition = this.index;\n                const savedErrors = [...this.errors];\n                let farthestIndex = this.index;\n                let farthestError: ParseError | null = null;\n\n                // Try each alternative\n                for (let i = 0; i < patterns.length; i++) {\n                    // Reset position for each attempt\n                    this.index = startPosition;\n                    this.errors = savedErrors;\n\n                    try {\n                        // Parse alternative with silent context for choice alternatives\n                        const result = this.parsePattern(patterns[i], parentRule);\n\n                        // Success - return immediately\n                        if (result !== null) {\n                            this.log('verbose', `CHOICE → alt ${i + 1}/${patterns.length} succeeded @${this.index}`);\n                            return result;\n                        }\n\n                        // Track the farthest we progressed and collect errors\n                        if (this.index > farthestIndex) {\n                            farthestIndex = this.index;\n                            const newErrors = this.errors.slice(savedErrors.length);\n                            if (newErrors.length > 0) {\n                                farthestError = newErrors[newErrors.length - 1];\n                            }\n                        }\n\n                    } catch (error) {\n                        // Track farthest progress even on exceptions\n                        if (this.index > farthestIndex) {\n                            farthestIndex = this.index;\n                            farthestError = this.normalizeError(error, this.getCurrentSpan());\n                        }\n                    }\n                }\n\n                // All alternatives failed\n                this.index = startPosition;\n                this.errors = savedErrors;\n\n                // In silent mode, just return null\n                if (shouldBeSilent || this.isInSilentMode()) {\n                    return null;\n                }\n\n                // Create meaningful error message\n                const errorMsg = farthestError\n                    ? `No matching alternative found: ${farthestError.msg}`\n                    // : `No matching pattern found in choice (tried ${patterns.length} alternatives)`;\n                    : `No matching pattern found in choice`;\n\n                const error = this.createError(\n                    farthestError?.code || 0x009,\n                    errorMsg,\n                    this.getCurrentSpan()\n                );\n\n                this.handleParseError(error, parentRule, 0);\n            }\n\n            private parseSequence(patterns: Pattern[], parentRule?: Rule, shouldBeSilent?: boolean): any {\n                this.log('verbose', `SEQUENCE[${patterns.length}] @${this.index}`);\n\n                // Empty sequence\n                if (patterns.length === 0) {\n                    return [];\n                }\n\n                const startPosition = this.index;\n                const savedErrors = [...this.errors];\n                const results: any[] = [];\n                let lastPatternIndex = 0;\n\n                try {\n                    // Parse each pattern in sequence\n                    for (lastPatternIndex = 0; lastPatternIndex < patterns.length; lastPatternIndex++) {\n                        const pattern = patterns[lastPatternIndex];\n                        const beforePatternIndex = this.index;\n\n                        // Parse current pattern\n                        const result = this.parsePattern(pattern, parentRule);\n\n                        // Pattern failed\n                        if (result === null) {\n                            // In silent mode, rollback and return null\n                            if (shouldBeSilent || this.isInSilentMode()) {\n                                this.index = startPosition;\n                                this.errors = savedErrors;\n                                return null;\n                            }\n\n                            // Create descriptive error\n                            const error = this.createError(\n                                0x006,\n                                `Sequence failed at element ${lastPatternIndex + 1}/${patterns.length}`,\n                                this.getCurrentSpan()\n                            );\n\n                            this.handleParseError(error, parentRule, lastPatternIndex);\n                        }\n\n                        // Add result to sequence (maintain structure even for null results)\n                        results.push(result);\n\n                        // Progress check (less strict for sequence since some patterns might not consume tokens)\n                        if (this.index === beforePatternIndex && !pattern.silent) {\n                            this.log('verbose', `⚠ No progress at sequence element ${lastPatternIndex} @${this.index}`);\n                        }\n\n                        // Skip ignored tokens between sequence elements\n                        this.skipIgnored(parentRule?.options?.ignored);\n                    }\n\n                    // All patterns succeeded\n                    this.log('verbose', `SEQUENCE → [${results.length}] @${this.index}`);\n                    return results;\n\n                } catch (e) {\n                    // Rollback on any error\n                    this.index = startPosition;\n                    this.errors = savedErrors;\n\n                    // Re-throw if not in silent mode\n                    if (!shouldBeSilent && !this.isInSilentMode()) {\n                        if(e instanceof Error) {\n                            this.handleFatalError(e);\n                        } else {\n                            const error = this.createError((e as ParseError).code, (e as ParseError).msg, (e as ParseError).span);\n                            this.handleParseError(error, parentRule, lastPatternIndex);\n                        }\n                    }\n\n                    return null;\n                }\n            }\n\n            private safeBuild(buildFn: Function, matches: any): any {\n                try {\n                    const input = Array.isArray(matches) ? matches : [matches];\n                    const result = buildFn(input);\n                    return result;\n                } catch (error) {\n                    // Only add build errors when not in silent mode\n                    if (!this.isInSilentMode()) {\n                        const buildError = this.createError(\n                            0x004,\n                            `Build function failed: ${(error as Error).message}`,\n                            this.getCurrentSpan()\n                        );\n                        this.addError(buildError);\n                        this.log('errors', `Build error: ${(error as Error).message}`);\n                    }\n\n                    // Return original matches as fallback\n                    return matches;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── SILENT MODE ───────────────────────────────┐\n\n            private shouldBeSilent(pattern: Pattern, rule?: Rule): boolean {\n                // Rule-level silent mode takes precedence\n                if (rule?.options?.silent === true) {\n                    return true;\n                }\n\n                // Pattern-level silent mode\n                if (pattern.silent === true) {\n                    return true;\n                }\n\n                // Inherit from parent context\n                if (this.silentContextStack.length > 0) {\n                    return this.silentContextStack[this.silentContextStack.length - 1];\n                }\n\n                return false;\n            }\n\n            private isInSilentMode(): boolean {\n                return this.silentContextStack.length > 0 &&\n                       this.silentContextStack[this.silentContextStack.length - 1];\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── HELP ───────────────────────────────┐\n\n            private normalizeSettings(settings ?: ParserSettings): ParserSettings {\n                const defaultSettings: ParserSettings = {\n                    startRule           : 'root',\n                    errorRecovery       : {\n                        mode            : 'strict',\n                        maxErrors       : 1,\n                        syncTokens      : []\n                    },\n                    ignored             : ['ws'],\n                    debug               : 'off',\n                    maxDepth            : 1000,\n                    maxCacheSize        : 1,\n                };\n\n                if(!settings) {\n                    return defaultSettings;\n                }\n\n                const mergedSettings = { ...defaultSettings, ...settings };\n\n                if (settings?.errorRecovery) {\n                    mergedSettings.errorRecovery = { ...defaultSettings.errorRecovery, ...settings.errorRecovery };\n                }\n\n                return mergedSettings;\n            }\n\n            private validateGrammar(): string[] {\n                const issues: string[] = [];\n                const ruleNames = new Set(Array.from(this.rules.keys()));\n\n                for (const [ruleName, rule] of this.rules) {\n                    const referencedRules = this.extractRuleReferences(rule.pattern);\n                    for (const ref of referencedRules) {\n                        if (!ruleNames.has(ref)) {\n                            issues.push(`Rule '${ruleName}' references undefined rule '${ref}'`);\n                        }\n                    }\n                }\n\n                if (!this.rules.has(this.settings.startRule)) {\n                    issues.push(`Start rule '${this.settings.startRule}' is not defined`);\n                }\n\n                return issues;\n            }\n\n            private extractRuleReferences(pattern: Pattern): string[] {\n                const refs: string[] = [];\n\n                switch (pattern.type) {\n                    case 'rule':\n                        refs.push(pattern.name);\n                        break;\n                    case 'repeat':\n                        refs.push(...this.extractRuleReferences(pattern.pattern));\n                        if (pattern.separator) {\n                            refs.push(...this.extractRuleReferences(pattern.separator));\n                        }\n                        break;\n                }\n\n                return refs;\n            }\n\n            private skipIgnored(ruleIgnored?: string[]): void {\n                if (this.ignoredSet.size === 0 && (!ruleIgnored?.length)) {\n                    return;\n                }\n\n                const combinedIgnored = ruleIgnored\n                    ? new Set([...this.ignoredSet, ...ruleIgnored])\n                    : this.ignoredSet;\n\n                while (this.index < this.tokens.length) {\n                    const token = this.tokens[this.index];\n                    if (!combinedIgnored.has(token.type)) break;\n                    this.index++;\n                    this.stats.tokensProcessed++;\n                }\n            }\n\n            private skipUntilTokens(tokens: string[]): void {\n                const tokenSet = new Set(tokens);\n                const maxIterations = 10000;\n                let skipped = 0;\n\n                while (this.index < this.tokens.length && skipped < maxIterations) {\n                    const currentToken = this.tokens[this.index];\n\n                    if (tokenSet.has(currentToken.type)) {\n                        this.log('errors', `Found sync token '${currentToken.type}' @${this.index}`);\n                        return;\n                    }\n                    this.index++;\n                    skipped++;\n                }\n            }\n\n            private deepClone(obj: any): any {\n                if (obj === null || typeof obj !== 'object') {\n                    return obj;\n                }\n\n                if (Array.isArray(obj)) {\n                    return obj.map(item => this.deepClone(item));\n                }\n\n                // Handle common AST node structure\n                if (obj.type || obj.span || obj.value) {\n                    const cloned: any = {};\n                    for (const [key, value] of Object.entries(obj)) {\n                        cloned[key] = this.deepClone(value);\n                    }\n                    return cloned;\n                }\n\n                return obj;\n            }\n\n            private resetState(tokens: Token[]): void {\n                this.tokens             = tokens;\n                this.index              = 0;\n                this.errors             = [];\n                this.ast                = [];\n                this.depth              = 0;\n                this.errorSeq           = 0;\n                this.indentLevel        = 0;\n                this.silentContextStack = []; // Reset silent context\n\n                // Reset memoization\n                this.memoCache.clear();\n                this.memoHits           = 0;\n                this.memoMisses         = 0;\n\n                this.stats              = {\n                    tokensProcessed     : 0,\n                    rulesApplied        : 0,\n                    errorsRecovered     : 0,\n                    parseTimeMs         : 0\n                };\n            }\n\n            private getCurrentToken() : Token {\n                return this.tokens[this.index];\n            }\n\n            private getCurrentSpan(): Span {\n                // Before any parsing\n                if (this.index === 0) {\n                    if (this.tokens.length > 0) {\n                        return {\n                            start: this.tokens[0].span.start,\n                            end: this.tokens[0].span.start\n                        };\n                    }\n                    return { start: 0, end: 0 };\n                }\n\n                // After parsing - get the span of current position\n                if (this.index >= this.tokens.length) {\n                    // End of tokens - use last token's end\n                    const lastToken = this.tokens[this.tokens.length - 1];\n                    return {\n                        start: lastToken.span.end,\n                        end: lastToken.span.end\n                    };\n                }\n\n                // Current token span\n                const currentToken = this.tokens[this.index];\n                return currentToken.span;\n            }\n\n            isNextToken(type: string, ignoredTokens?: string[]): boolean {\n                ignoredTokens = [...(ignoredTokens ?? []), ...this.settings.ignored!];\n                let currentIndex = this.index;\n\n                while (currentIndex < this.tokens.length) {\n                    const currentToken = this.tokens[currentIndex];\n                    if (currentToken.type == type) {\n                        return true;\n                    }\n                    if (ignoredTokens.includes(currentToken.type)) {\n                        currentIndex++;\n                    } else {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            isPrevToken(type: string, ignoredTokens?: string[]): boolean {\n                ignoredTokens = [...(ignoredTokens ?? []), ...this.settings.ignored!];\n                let currentIndex = this.index - 1;\n\n                while (currentIndex >= 0) {\n                    const currentToken = this.tokens[currentIndex];\n                    if (currentToken.type == type) {\n                        return true;\n                    }\n                    if (ignoredTokens.includes(currentToken.type)) {\n                        currentIndex--;\n                    } else {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── ERROR ──────────────────────────────┐\n\n            private createError(code: number, msg: string, span?: Span): ParseError {\n                return {\n                    code,\n                    msg,\n                    span: span || this.getCurrentSpan()\n                };\n            }\n\n            private addError(error: ParseError): void {\n                // Don't add errors in silent mode\n                if (this.isInSilentMode()) {\n                    return;\n                }\n\n                // Check maximum error limit\n                const maxErrors = this.settings.errorRecovery!.maxErrors!;\n                if (maxErrors !== 0 && this.errors.length >= maxErrors) {\n                    return;\n                }\n\n                // In strict mode, only allow one error\n                if (this.settings.errorRecovery!.mode === 'strict' && this.errors.length > 0) {\n                    return;\n                }\n\n                this.errors.push(error);\n                this.log('errors', `⚠ ${error.msg} @${error.span.start}:${error.span.end}`);\n            }\n\n            private handleParseError(error: ParseError, rule?: Rule, failedAt: number = 0): never {\n                // Try to get custom error from rule\n                const finalError = this.getCustomErrorOr(rule, error, failedAt);\n                throw finalError;\n            }\n\n            private handleFatalError(error: any): void {\n                const parseError = this.normalizeError(error, this.getCurrentSpan());\n                this.addError(parseError);\n                this.log('errors', `💥 Fatal error: ${parseError.msg} @${this.index}`);\n            }\n\n            private getCustomErrorOr(rule: Rule | null | undefined, defaultError: ParseError, failedAt: number = 0): ParseError {\n                if (!rule?.options?.errors) {\n                    return defaultError;\n                }\n\n                // Try to find matching error handler\n                for (const errorHandler of rule.options.errors) {\n                    let matches = false;\n\n                    if (typeof errorHandler.cond === 'number') {\n                        matches = (failedAt === errorHandler.cond);\n                    } else if (typeof errorHandler.cond === 'function') {\n                        try {\n                            matches = errorHandler.cond(this, failedAt, false);\n                        } catch {\n                            matches = false;\n                        }\n                    }\n\n                    if (matches) {\n                        return this.createError(\n                            errorHandler.code || 0x007,\n                            errorHandler.msg,\n                            defaultError.span\n                        );\n                    }\n                }\n\n                return defaultError;\n            }\n\n            private normalizeError(error: any, defaultSpan: Span): ParseError {\n                // Already a ParseError\n                if (error && typeof error === 'object' && 'msg' in error && 'code' in error && 'span' in error) {\n                    return error as ParseError;\n                }\n\n                // Regular Error\n                if (error instanceof Error) {\n                    return this.createError(0x404, error.message, defaultSpan);\n                }\n\n                // Unknown error type\n                return this.createError(0x500, `Unknown error: ${error}`, defaultSpan);\n            }\n\n            private applyRecovery(rule?: Rule, startIndex?: number): void {\n                const recovery = rule?.options?.recovery;\n\n                if (recovery) {\n                    this.applyRecoveryStrategy(recovery);\n                } else {\n                    this.defaultErrorRecovery();\n                }\n\n                this.stats.errorsRecovered++;\n\n                // Prevent infinite loops\n                if (startIndex !== undefined && this.index === startIndex && this.index < this.tokens.length) {\n                    this.index++;\n                }\n            }\n\n            private applyRecoveryStrategy(strategy: RecoveryStrategy): void {\n                const beforePos = this.index;\n                this.log('errors', `🔧 Recovery: ${strategy.type} @${beforePos}`);\n\n                switch (strategy.type) {\n                    case 'panic':\n                        this.defaultErrorRecovery();\n                        break;\n                    case 'skipUntil':\n                        const tokens = strategy.tokens || (strategy.token ? [strategy.token] : []);\n                        this.skipUntilTokens(tokens);\n                        break;\n                    default:\n                        this.defaultErrorRecovery();\n                }\n\n                this.log('errors', `Recovery: ${beforePos} → ${this.index}`);\n            }\n\n            private defaultErrorRecovery(): void {\n                const syncTokens = this.settings.errorRecovery!.syncTokens!;\n\n                if (syncTokens.length > 0) {\n                    this.skipUntilTokens(syncTokens);\n                } else if (this.index < this.tokens.length) {\n                    this.index++;\n                }\n            }\n\n        // └─────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── DEBUG ──────────────────────────────┐\n\n            private log(level: DebugLevel, message: string): void {\n                if (this.debugLevel === 'off') return;\n\n                const levels: DebugLevel[] = ['off', 'errors', 'rules', 'patterns', 'tokens', 'verbose'];\n                const currentIndex = levels.indexOf(this.debugLevel);\n                const messageIndex = levels.indexOf(level);\n\n                if (messageIndex <= currentIndex) {\n                    const prefix = this.getDebugPrefix(level);\n                    console.log(`${prefix} ${message}`);\n                }\n            }\n\n            private getDebugPrefix(level: DebugLevel): string {\n                const prefixes: { [key: string]: string } = {\n                    errors      : '🔥',\n                    rules       : '📋',\n                    patterns    : '🔍',\n                    tokens      : '🎯',\n                    verbose     : '📝'\n                };\n\n                return `[${prefixes[level] || (level === 'off' ? '⚡' : '')}]`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── CACHE ──────────────────────────────┐\n\n            public dispose(): void {\n                this.memoCache.clear();\n                this.rules.clear();\n                this.ignoredSet.clear();\n                this.tokens     = [];\n                this.ast        = [];\n                this.errors     = [];\n                this.silentContextStack = [];\n            }\n\n            private cleanMemoCache(): void {\n                const entries = Array.from(this.memoCache.entries());\n                const now = Date.now();\n\n                // Remove old entries and invalid ones\n                const validEntries = entries.filter(([key, value]) => {\n                    // Remove entries older than 1 second (adjust as needed)\n                    if (now - (value.cachedAt || 0) > 1000) {\n                        return false;\n                    }\n\n                    // Remove entries that don't match current parsing context\n                    if (value.errorCount !== this.errors.length) {\n                        return false;\n                    }\n\n                    return true;\n                });\n\n                // Keep only half of the valid entries (LRU-like)\n                const keepCount = Math.floor(validEntries.length / 2);\n\n                this.memoCache.clear();\n\n                // Keep the more recent entries\n                for (let i = validEntries.length - keepCount; i < validEntries.length; i++) {\n                    this.memoCache.set(validEntries[i][0], validEntries[i][1]);\n                }\n\n                this.log('verbose', `🧹 Memo cache cleaned: kept ${keepCount} of ${entries.length} entries`);\n            }\n\n            private createMemoKey(patternType: string, patternData: any, position: number, ruleName?: string): string {\n                // Include silent context in key\n                const silentContext = this.isInSilentMode() ? 'S' : 'L'; // S=Silent, L=Loud\n\n                // Include error recovery state (simplified)\n                const errorContext = this.errors.length > 0 ? `E${this.errors.length}` : 'E0';\n\n                // Create base key with context\n                const baseKey = `${patternType}:${position}:${silentContext}:${errorContext}`;\n\n                if (ruleName) {\n                    // For rules, include rule-specific context\n                    const rule = this.rules.get(ruleName);\n                    const ruleContext = this.getRuleContext(rule);\n                    return `rule:${ruleName}:${ruleContext}:${baseKey}`;\n                }\n\n                // For patterns, include pattern-specific data\n                switch (patternType) {\n                    case 'token':\n                        return `${baseKey}:${patternData.name}`;\n                    case 'repeat':\n                        return `${baseKey}:${patternData.min || 0}:${patternData.max || 'inf'}:${patternData.separator ? 'sep' : 'nosep'}`;\n                    case 'seq':\n                    case 'choice':\n                        // Include pattern count and a simple hash of pattern types\n                        const patternHash = this.hashPatterns(patternData.patterns || []);\n                        return `${baseKey}:${patternData.patterns?.length || 0}:${patternHash}`;\n                    default:\n                        return baseKey;\n                }\n            }\n\n            private getRuleContext(rule?: Rule): string {\n                if (!rule) return 'none';\n\n                // Create a simple hash of rule characteristics that affect parsing\n                const hasBuilder = rule.options?.build ? 'B' : '';\n                const hasErrors = rule.options?.errors?.length ? 'E' : '';\n                const hasRecovery = rule.options?.recovery ? 'R' : '';\n                const isSilent = rule.options?.silent ? 'S' : '';\n\n                return `${hasBuilder}${hasErrors}${hasRecovery}${isSilent}`;\n            }\n\n            private hashPatterns(patterns: Pattern[]): string {\n                // Simple hash based on pattern types and structure\n                return patterns.map(p => `${p.type}${p.silent ? 'S' : ''}`).join('');\n            }\n\n            private getMemoized(key: string): { hit: boolean; result?: any; newIndex?: number } {\n                if (!this.settings.maxCacheSize || this.memoCache.size >= this.settings.maxCacheSize) {\n                    return { hit: false };\n                }\n\n                const cached = this.memoCache.get(key);\n                if (cached !== undefined) {\n                    // Additional validation: ensure the cached result is still valid\n                    if (this.isCachedResultValid(cached, key)) {\n                        this.memoHits++;\n                        this.log('verbose', `🔋 Memo HIT: ${key} → ${cached.newIndex}`);\n                        return { hit: true, result: cached.result, newIndex: cached.newIndex };\n                    } else {\n                        // Invalid cached result, remove it\n                        this.memoCache.delete(key);\n                        this.log('verbose', `🗑️ Memo INVALID: ${key}`);\n                    }\n                }\n\n                this.memoMisses++;\n                return { hit: false };\n            }\n\n            private isCachedResultValid(cached: any, key: string): boolean {\n                // Basic sanity checks\n                if (typeof cached.newIndex !== 'number' || cached.newIndex < 0) {\n                    return false;\n                }\n\n                // Don't use cached results that would go beyond current token length\n                if (cached.newIndex > this.tokens.length) {\n                    return false;\n                }\n\n                // Additional checks can be added here based on your specific needs\n                return true;\n            }\n\n            private memoize(key: string, result: any, startIndex: number, endIndex: number): void {\n                if (!this.settings.maxCacheSize || this.memoCache.size >= this.settings.maxCacheSize) {\n                    return;\n                }\n\n                // Don't memoize results that made no progress and failed\n                // This prevents caching failed attempts that might succeed later\n                if (result === null && startIndex === endIndex) {\n                    this.log('verbose', `⚠️ Skip memo (no progress): ${key}`);\n                    return;\n                }\n\n                // Don't memoize if we're in an error recovery state\n                // Error recovery can change parsing behavior\n                if (this.errors.length > 0 && this.stats.errorsRecovered > 0) {\n                    this.log('verbose', `⚠️ Skip memo (error state): ${key}`);\n                    return;\n                }\n\n                // Clean cache if it gets too large\n                if (this.memoCache.size >= this.settings.maxCacheSize * 0.9) {\n                    this.cleanMemoCache();\n                }\n\n                const memoEntry = {\n                    result: this.deepClone(result), // Clone to avoid reference issues\n                    newIndex: endIndex,\n                    // Store additional metadata for validation\n                    cachedAt: Date.now(),\n                    silentContext: this.isInSilentMode(),\n                    errorCount: this.errors.length\n                };\n\n                this.memoCache.set(key, memoEntry);\n                this.log('verbose', `📝 Memo SET: ${key} → ${endIndex}`);\n            }\n\n            private shouldUseMemoization(pattern: Pattern, parentRule?: Rule): boolean {\n                // Don't memoize during error recovery\n                if (this.stats.errorsRecovered > 0 && this.errors.length > 0) {\n                    return false;\n                }\n\n                // Don't memoize for simple tokens (overhead not worth it)\n                if (pattern.type === 'token') {\n                    return false;\n                }\n\n                // Don't memoize recursive rules to avoid infinite loops\n                if (pattern.type === 'rule' && this.isRecursiveContext(pattern.name)) {\n                    return false;\n                }\n\n                // For complex patterns and rules, memoization is beneficial\n                return pattern.type === 'rule' ||\n                    pattern.type === 'choice' ||\n                    pattern.type === 'seq' ||\n                    (pattern.type === 'repeat' && (pattern.min > 1 || pattern.max > 1));\n            }\n\n            private isRecursiveContext(ruleName: string): boolean {\n                // Simple check: if we're already parsing this rule in our call stack\n                // This is a basic implementation - you might need more sophisticated detection\n\n                // Count how many times this rule appears in current parsing context\n                // by checking if we're deeply nested in the same rule\n                return this.depth > 10; // Simple heuristic - adjust based on your grammar\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔═══════════════════════════════════════════ MAIN ════════════════════════════════════════════╗\n\n    /**\n     * Parses an array of tokens using the provided rules and settings.\n     * @param tokens    - The array of tokens to parse.\n     * @param rules     - The set of rules to use for parsing.\n     * @param settings  - Additional settings to customize parsing behavior.\n     *\n     * @returns The result of the parsing operation, including the parsed AST and any errors encountered.\n    */\n    export function parse(tokens: Token[], rules: Rules, settings?: ParserSettings): ParseResult {\n        // create new parser\n        const parser = new Parser(rules, settings);\n\n        // parse\n        try     { return parser.parse(tokens); }\n        finally { parser.dispose(); }\n    }\n\n    /**\n     * Creates a rule definition object.\n     * @param name      - The name of the rule.\n     * @param pattern   - The pattern to match against.\n     * @param options   - Additional options for the rule.\n     *\n     * @returns A rule definition object.\n     *\n     * @throws  Throws an error if `name` is falsy or not a string.\n     * @throws  Throws an error if `pattern` is falsy or not an object.\n     */\n    export function createRule(name: string, pattern: Pattern, options?: Rule['options']): Rule {\n        if (!name || typeof name !== 'string') {\n            throw new Error('Rule name must be a non-empty string');\n        }\n        if (!pattern || typeof pattern !== 'object') {\n            throw new Error('Rule pattern must be an object');\n        }\n        return { name, pattern, options };\n    }\n\n\n    // ════ Pattern Combinators ════\n\n\n    /**\n     * Creates a pattern that matches a specific token.\n     *\n     * @param {string} name             - The name of the token to match.\n     * @param {boolean} [silent=false]  - A flag that indicates whether the matched token should be ignored during parsing (silent mode).\n     *\n     * @returns {Pattern} The pattern object representing the token.\n     *\n     * @throws {Error} Throws an error if `name` is falsy or not a string.\n    */\n    export function token(name: string, silent: boolean = false): Pattern {\n        if (!name || typeof name !== 'string') {\n            throw new Error('Token name must be a non-empty string');\n        }\n        return { type: 'token', name, silent };\n    }\n\n    /**\n     * Creates a new pattern that matches a rule definition.\n     *\n     * @param {string} name             - The name of the rule to match.\n     * @param {boolean} [silent=false]  - A flag that indicates whether the matched rule should be ignored during parsing (silent mode).\n     *\n     * @returns {Pattern} A pattern object that matches the specified rule.\n     *\n     * @throws {Error} Throws an error if `name` is falsy or not a string.\n    */\n    export function rule(name: string, silent: boolean = false): Pattern {\n        if (!name || typeof name !== 'string') {\n            throw new Error('Rule name must be a non-empty string');\n        }\n        return { type: 'rule', name, silent };\n    }\n\n    /**\n     * Creates a new pattern that matches a specified number of occurrences of the given pattern.\n     *\n     * @param {Pattern} pattern         - The pattern to match.\n     * @param {number} [min=0]          - The minimum number of times the pattern must be matched.\n     * @param {number} [max=Infinity]   - The maximum number of times the pattern can be matched.\n     * @param {Pattern} [separator]     - A pattern to match between occurrences.\n     * @param {boolean} [silent=false]  - A flag that indicates whether the matched text should be hidden in the output.\n     *\n     * @returns {Pattern} A new pattern that matches between `min` and `max` occurrences of the given pattern.\n     *\n     * @throws {Error} Throws an error if `min` is negative or `max` is less than `min`.\n    */\n    export function repeat(pattern: Pattern, min = 0, max = Infinity, separator?: Pattern, silent: boolean = false): Pattern {\n        if (min < 0) {\n            throw new Error('Minimum repetition count cannot be negative');\n        }\n        if (max < min) {\n            throw new Error('Maximum repetition count cannot be less than minimum');\n        }\n        return { type: 'repeat', pattern, min, max, separator, silent };\n    }\n\n    /**\n     * Creates a new pattern that matches one or more occurrences of the given pattern.\n     *\n     * @param {Pattern} pattern         - The pattern to match one or more times.\n     * @param {Pattern} [separator]     - A pattern to match between occurrences.\n     * @param {boolean} [silent=false]  - A flag that indicates whether the matched text should be hidden in the output.\n     *\n     * @return {Pattern} A new pattern that matches one or more occurrences of the given pattern.\n    */\n    export function oneOrMore(pattern: Pattern, separator?: Pattern, silent: boolean = false): Pattern {\n        return repeat(pattern, 1, Infinity, separator, silent);\n    }\n\n    /**\n     * Creates a new pattern that matches zero or more occurrences of the given pattern.\n     *\n     * @param {Pattern} pattern         - The pattern to match zero or more times.\n     * @param {Pattern} [separator]     - A pattern to match between occurrences.\n     * @param {boolean} [silent=false]  - A flag that indicates whether the matched text should be hidden in the output.\n     *\n     * @return {Pattern} A new pattern that matches zero or more occurrences of the given pattern.\n    */\n    export function zeroOrMore(pattern: Pattern, separator?: Pattern, silent: boolean = false): Pattern {\n        return repeat(pattern, 0, Infinity, separator, silent);\n    }\n\n    /**\n     * Creates a new pattern that matches zero or one occurrence of the given pattern.\n     *\n     * @param {Pattern} pattern         - The pattern to match zero or one time.\n     * @param {Pattern} [separator]     - A pattern to match between occurrences.\n     * @param {boolean} [silent=true]   - A flag that indicates whether the matched text should be hidden in the output.\n     *\n     * @return {Pattern} A new pattern that matches zero or one occurrence of the given pattern.\n    */\n    export function zeroOrOne(pattern: Pattern, separator?: Pattern, silent: boolean = true): Pattern {\n        return repeat(pattern, 0, 1, separator, silent);\n    }\n\n    /**\n     * Matches a single occurrence of the given pattern. If the pattern fails to match, it will return an array with\n     * a single error. This is useful when you want to ensure that a pattern is matched once and only once, and if it\n     * fails to match, you want to return a specific error.\n     *\n     * @param {Pattern} pattern         - The pattern to match.\n     * @param {boolean} [silent=false]  - Whether the pattern should be silent (not fail on error).\n     *\n     * @return {Pattern} A pattern that matches the given pattern exactly once.\n     *\n     * @example\n     * // Example usage of errorOrArrayOfOne:\n     * parser.createRule('Expression',\n     *     parser.errorOrArrayOfOne(parser.silent(parser.rule('PrimaryExpression'))),\n     *     {\n     *         build: (matches) => {\n     *             return {\n     *                 kind    : 'Expression',\n     *                 span    : matches[0] && matches[0].span ? matches[0].span : { start: 0, end: 0 },\n     *                 body    : matches[0]\n     *             };\n     *         },\n     *\n     *         silent: false,\n     *\n     *         errors: [parser.error(0, \"Expected Expression\")],\n     *     }\n     * ),\n     *\n     * // If the pattern fails to match, it will return just one error: \"Expected Expression\".\n    */\n    export function errorOrArrayOfOne(pattern: Pattern, silent: boolean = false): Pattern {\n        return repeat(pattern, 1, 1, undefined, silent);\n    }\n\n    /**\n     * Creates a new pattern that matches zero or one occurrence of the given pattern.\n     *\n     * @param {Pattern} pattern     - The pattern to match zero or one time.\n     *\n     * @return {Pattern} A new pattern that matches zero or one occurrence of the given pattern.\n    */\n    export function optional(pattern: Pattern): Pattern {\n        return repeat(pattern, 0, 1, undefined, true);\n    }\n\n    /**\n     * Creates a new pattern that matches one of multiple patterns. Throws an error if the choice has no patterns.\n     *\n     * @param {...Pattern} patterns     - The patterns to match, at least one is required.\n     *\n     * @return {Pattern} A new pattern that matches one of the given patterns.\n     *\n     * @throws {Error} Throws an error if the choice has no patterns.\n     */\n    export function choice(...patterns: Pattern[]): Pattern {\n        if (patterns.length === 0) {\n            throw new Error('Choice must have at least one pattern');\n        }\n        return { type: 'choice', patterns, silent: false };\n    }\n\n    /**\n     * Creates a new pattern that matches multiple patterns in sequence. Throws an error if the sequence has no patterns.\n     *\n     * @param {...Pattern} patterns     - The patterns to match in sequence.\n     *\n     * @return {Pattern} A new pattern that matches the given patterns in sequence.\n     *\n     * @throws {Error} Throws an error if the sequence has no patterns.\n    */\n    export function seq(...patterns: Pattern[]): Pattern {\n        if (patterns.length === 0) {\n            throw new Error('Sequence must have at least one pattern');\n        }\n        return { type: 'seq', patterns, silent: false };\n    }\n\n\n    // ════ Silent Mode Helpers ════\n\n\n    /**\n     * Creates a new pattern that matches the given pattern but is not outputted\n     * in the AST.\n     *\n     * @param {Pattern} pattern     - The pattern to match but not output.\n     *\n     * @return {Pattern} A new pattern that matches the given pattern but is not\n     * outputted in the AST.\n     */\n    export function silent<T extends Pattern>(pattern: T): T {\n        return { ...pattern, silent: true };\n    }\n\n    /**\n     * Creates a new pattern that matches the given pattern and is outputted in\n     * the AST.\n     *\n     * @param {Pattern} pattern     - The pattern to match and output.\n     *\n     * @return {Pattern} A new pattern that matches the given pattern and is\n     * outputted in the AST.\n     */\n    export function loud<T extends Pattern>(pattern: T): T {\n        return { ...pattern, silent: false };\n    }\n\n\n    // ════ Error Handling ════\n\n\n    /**\n     * Creates a new ErrorHandler pattern that matches when the given condition is true\n     * and throws an error with the given message and code.\n     *\n     * @param {ErrorHandler['cond']} cond   - The condition function that determines if the error should be thrown.\n     * @param {string} msg                  - The error message to throw.\n     * @param {number} [code=0x999]         - The error code to throw.\n     *\n     * @return {ErrorHandler} A new ErrorHandler pattern that matches the given condition and throws an error.\n     */\n    export function error( cond: ErrorHandler['cond'], msg: string, code?: number, ): ErrorHandler {\n        return { cond, msg, code: code ?? 0x999 };\n    }\n\n    /**\n     * A collection of error recovery strategies.\n     *\n     * @type {Object}\n     * @property {RecoveryStrategy} panicMode - Creates a recovery strategy that stops parsing and throws an error with code 0xAAA.\n     * @property {RecoveryStrategy} skipUntil - Creates a recovery strategy that skips input tokens until it finds any of the given tokens.\n    */\n    export const errorRecoveryStrategies = {\n        /**\n         * Creates a recovery strategy that stops parsing and throws an error with code 0xAAA.\n         *\n         * @return {RecoveryStrategy} A recovery strategy that stops parsing.\n         */\n        panicMode(): RecoveryStrategy {\n            return { type: 'panic' };\n        },\n\n        /**\n         * Creates a recovery strategy that skips input tokens until it finds any of the given tokens.\n         *\n         * @param {string | string[]} tokens - The tokens to skip until.\n         * @return {RecoveryStrategy} A recovery strategy that skips input tokens until it finds any of the given tokens.\n         */\n        skipUntil(tokens: string | string[]): RecoveryStrategy {\n            return { type: 'skipUntil', tokens: Array.isArray(tokens) ? tokens : [tokens] };\n        },\n    };\n\n\n    // ════ Helpers ════\n\n\n    /**\n     * Returns the smallest span that encompasses all the given matches, or the span of the first match\n     * if there are no matches.\n     *\n     * @param {any[]} matches - An array of matches each containing a span property.\n     *\n     * @return {Span | undefined} The smallest span that encompasses all the given matches, or the span\n     * of the first match if there are no matches.\n     */\n    export function getMatchesSpan(matches: any[]): Span | undefined {\n        if (!matches || matches.length === 0) {\n            return undefined;\n        }\n\n        let firstSpan: Span | null = null;\n        let lastSpan: Span | null = null;\n\n        for (const match of matches) {\n            if (match && match.span) {\n                if (!firstSpan) {\n                    firstSpan = match.span;\n                }\n                lastSpan = match.span;\n            }\n        }\n\n        if (firstSpan && lastSpan) {\n            return {\n                start: firstSpan.start,\n                end: lastSpan.end\n            };\n        }\n\n        if (firstSpan) {\n            return firstSpan;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Returns a new object that is a shallow copy of the given 'res' object, but without the 'span' property.\n     *\n     * @param {any} res - An object to be copied, with any 'span' property removed.\n     *\n     * @return {any} A new object that is a shallow copy of the given 'res' object, but without the 'span' property.\n     */\n    export function resWithoutSpan(res: any): any {\n        const result = { ...res };\n        delete result.span;\n        return result;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":"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","names":["rule","token","error","silent"]}