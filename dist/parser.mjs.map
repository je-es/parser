{"version":3,"sources":["../lib/parser.ts"],"sourcesContent":["// parser.ts — Advanced syntax analyzer that converts tokens\n//             into AST with customizable grammar rules and intelligent error detection.\n//\n// repo   : https://github.com/je-es/parser\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    export interface Token {\n        kind            : string;\n        value           : string | null;\n        span            : Span;\n    }\n\n    export interface Span {\n        start           : number;\n        end             : number;\n    }\n\n    export interface Pattern {\n        type            : 'token' | 'rule' | 'repeat' | 'choice' | 'seq' | 'optional';\n        [key: string]   : any;\n        silent          : boolean;\n    }\n\n    export interface ErrorHandler {\n        cond            : number | ((parser: Parser, opt: { failedAt: number, tokenIndex: number, force?: boolean, prevRule?: string, prevInnerRule?: string }) => boolean);\n        msg             : string;\n        code?           : number;\n    }\n\n    export interface RecoveryStrategy {\n        type            : 'skipUntil';\n        tokens?         : string[];\n        token?          : string;\n    }\n\n    export interface Rule {\n        name            : string;\n        pattern         : Pattern;\n        options?        : {\n            build?      : (matches: any[]) => any;\n            errors?     : ErrorHandler[];\n            recovery?   : RecoveryStrategy;\n            ignored?    : string[];\n            silent?     : boolean;\n        };\n    }\n\n    export type Rules = Rule[];\n\n    export interface ParseStatistics {\n        tokensProcessed : number;\n        rulesApplied    : number;\n        errorsRecovered : number;\n        parseTimeMs     : number;\n    }\n\n    export type BaseAstNode = {\n        rule            : string;\n        span            : Span;\n        value?          : string | number | boolean | null;\n    }\n\n    export type AstNode = BaseAstNode | any;\n\n    export interface ParseError {\n        msg             : string;\n        code            : number;\n        span            : Span;\n        failedAt        : number;\n        tokenIndex      : number;\n        prevRule        : string;\n        prevInnerRule?  : string;\n    }\n\n    export interface ParseResult {\n        ast             : AstNode[];\n        errors          : ParseError[];\n        statistics?     : ParseStatistics;\n    }\n\n    export type DebugLevel = 'off' | 'errors' | 'rules' | 'patterns' | 'tokens' | 'verbose';\n\n    export interface ParserSettings {\n        startRule       : string;\n        errorRecovery?  : {\n            mode?       : 'strict' | 'resilient';\n            maxErrors?  : number;\n        };\n        ignored?        : string[];\n        debug?          : DebugLevel;\n        maxDepth?       : number;\n        maxCacheSize?   : number;\n    }\n\n    export const ERRORS = {\n        // Core parsing errors (0x000 - 0x099)\n        LEXICAL_ERROR           : 0x000,\n        TOKEN_EXPECTED_EOF      : 0x001,\n        TOKEN_MISMATCH          : 0x002,\n        RULE_FAILED             : 0x003,\n        BUILD_FUNCTION_FAILED   : 0x004,\n        REPEAT_MIN_NOT_MET      : 0x005,\n        SEQUENCE_FAILED         : 0x006,\n        CUSTOM_ERROR            : 0x007,\n\n        // Choice and alternatives (0x008 - 0x00F)\n        CHOICE_ALL_FAILED       : 0x009,\n\n        // System errors (0x400 - 0x4FF)\n        FATAL_ERROR             : 0x404,\n        UNKNOWN_ERROR           : 0x500,\n\n        // Recovery and validation (0x900 - 0x999)\n        RECOVERY_CUSTOM         : 0x999,\n    } as const;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Parser {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            // Core data\n            public rules            : Map<string, Rule>;\n            public settings         : ParserSettings;\n\n            // State\n            public tokens           : Token[] = [];\n            public ast              : AstNode[] = [];\n            public errors           : ParseError[] = [];\n            public index            : number = 0;\n            public depth            : number = 0;\n\n            // Debug & stats\n            private debugLevel      : DebugLevel;\n            private indentLevel     : number = 0;\n            public stats            : ParseStatistics;\n            public startTime        : number = 0;\n            public errorSeq         : number = 0;\n\n            // Performance\n            public memoCache        : Map<string, any> = new Map();\n            public ignoredSet       : Set<string> = new Set();\n            public memoHits         : number = 0;\n            public memoMisses       : number = 0;\n\n            // Context tracking\n            private silentContextStack  : boolean[] = [];\n            public lastVisitedIndex     : number = 0;\n            public lastHandledRule      : string = 'unknown';\n            public ruleStack            : string[] = [];\n            public patternStack         : string[] = [];\n            public lastInnerRule        : string = 'unknown';\n            public lastCompletedRule    : string = 'unknown';\n            public successfulRules      : string[] = [];\n            private globalSuccessRules  : string[] = [];\n            private lastLeafRule        : string = 'unknown';\n\n            constructor(rules: Rule[], settings?: ParserSettings) {\n                this.rules          = new Map(rules.map(rule => [rule.name, rule]));\n                this.settings       = this.normalizeSettings(settings);\n                this.debugLevel     = this.settings.debug!;\n                this.ignoredSet     = new Set(this.settings.ignored!);\n\n                this.stats = { tokensProcessed: 0, rulesApplied: 0, errorsRecovered: 0, parseTimeMs: 0 };\n\n                const grammarIssues = this.validateGrammar();\n                if (grammarIssues.length > 0) {\n                    throw new Error(`Grammar validation failed: ${grammarIssues.join(', ')}`);\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            parse(tokens: Token[]): ParseResult {\n                this.resetState(tokens);\n                this.startTime = Date.now();\n                this.log('rules', `🚀 Parse started: ${tokens.length} tokens`);\n\n                // Early validation\n                if (!tokens?.length) return { ast: [], errors: [] };\n\n                const errorToken = tokens.find(token => token.kind === 'error');\n                if (errorToken) {\n                    return {\n                        ast: [],\n                        errors: [this.createError(ERRORS.LEXICAL_ERROR, `Unexpected token '${errorToken.value}'`, errorToken.span, 0, 0, this.lastHandledRule)]\n                    };\n                }\n\n                try {\n                    const startRule = this.rules.get(this.settings.startRule);\n                    if (!startRule) {\n                        throw new Error(`Start rule '${this.settings.startRule}' not found`);\n                    }\n\n                    this.skipIgnored();\n                    this.parseWithRecovery(startRule);\n                    this.skipIgnored();\n                } catch (err: any) {\n                    this.handleFatalError(err);\n                }\n\n                this.stats.parseTimeMs = Date.now() - this.startTime;\n                this.log('rules', `✅ Parse completed: ${this.ast.length} nodes, ${this.errors.length} errors (${this.stats.parseTimeMs}ms)`);\n                this.log('verbose', `📊 Memo stats: ${this.memoHits} hits, ${this.memoMisses} misses, ${this.memoCache.size} cached entries`);\n\n                return {\n                    ast: this.ast,\n                    errors: this.errors,\n                    statistics: this.stats\n                };\n            }\n\n            private parseWithRecovery(startRule: Rule): void {\n                const maxErrors = this.settings.errorRecovery!.maxErrors!;\n                let consecutiveErrors = 0;\n\n                while (this.index < this.tokens.length && (maxErrors === 0 || this.errors.length < maxErrors)) {\n                    const beforeIndex = this.index;\n\n                    try {\n                        const result = this.parsePattern(startRule.pattern, startRule);\n\n                        if (result !== null) {\n                            const processed = startRule.options?.build\n                                ? this.safeBuild(startRule.options.build, result)\n                                : result;\n\n                            if (processed !== null) {\n                                this.ast.push(processed);\n                            }\n                        }\n\n                        consecutiveErrors = 0;\n\n                        if (this.index >= this.tokens.length || this.index === beforeIndex) {\n                            break;\n                        }\n                    } catch (error: any) {\n                        consecutiveErrors++;\n\n                        const parseError = this.normalizeError(error, this.getCurrentSpan());\n                        this.addError(parseError);\n\n                        // FIXED: Better error recovery application\n                        if (this.settings.errorRecovery!.mode === 'resilient') {\n                            this.applyRecovery(startRule, beforeIndex);\n\n                            // Force progress if we're stuck\n                            if (this.index === beforeIndex && this.index < this.tokens.length) {\n                                this.index++;\n                            }\n                        } else {\n                            // In strict mode, stop after first error\n                            break;\n                        }\n\n                        if (consecutiveErrors > 10) {\n                            break;\n                        }\n                    }\n\n                    this.skipIgnored();\n                }\n            }\n\n            protected parsePattern(pattern: Pattern, parentRule?: Rule): any {\n                this.lastHandledRule = pattern.type;\n\n                if (this.depth > this.settings.maxDepth!) {\n                    throw new Error('Maximum parsing depth exceeded');\n                }\n\n                // CRITICAL FIX: Better silent context management\n                const shouldBeSilent = this.shouldBeSilent(pattern, parentRule);\n\n                // For optional patterns, we need special handling\n                const isOptionalContext = parentRule?.name === 'optional' ||\n                                        this.patternStack[this.patternStack.length - 1] === 'optional';\n\n                this.silentContextStack.push(shouldBeSilent || isOptionalContext);\n\n                const startIndex = this.index;\n                const memoKey = this.shouldUseMemoization(pattern, parentRule)\n                    ? this.createMemoKey(pattern.type, pattern, startIndex, parentRule?.name)\n                    : null;\n\n                // Check memoization\n                if (memoKey) {\n                    const memoResult = this.getMemoized(memoKey);\n                    if (memoResult.hit) {\n                        this.index = memoResult.newIndex!;\n                        this.silentContextStack.pop();\n                        this.log('verbose', `🔋 Memo HIT: ${memoKey} → ${memoResult.newIndex}`);\n                        return memoResult.result;\n                    }\n                }\n\n                this.indentLevel++;\n                this.log('patterns', `${'  '.repeat(this.indentLevel)}⚡ ${pattern.type}${parentRule ? ` (${parentRule.name})` : ''}${shouldBeSilent ? ' [SILENT]' : ''} @${this.index}`);\n                this.depth++;\n\n                let result: any = null;\n\n                try {\n                    this.skipIgnored(parentRule?.options?.ignored);\n\n                    result = this.executePattern(pattern, parentRule, shouldBeSilent);\n\n                    const status = result !== null ? '✓' : '✗';\n                    this.log('patterns', `${'  '.repeat(this.indentLevel)}${status} ${pattern.type} → ${this.index}`);\n\n                    // CRITICAL FIX: Only memoize if we're not in an error state\n                    if (memoKey && !isOptionalContext) {\n                        this.memoize(memoKey, result, startIndex, this.index);\n                    }\n\n                    return result;\n                } catch (error) {\n                    // In optional context, don't let errors propagate up\n                    if (isOptionalContext) {\n                        this.index = startIndex;\n                        this.log('patterns', `${'  '.repeat(this.indentLevel)}✗ ${pattern.type} (optional context, suppressed) → ${startIndex}`);\n                        return null;\n                    }\n                    throw error;\n                } finally {\n                    this.depth--;\n                    this.indentLevel--;\n                    this.silentContextStack.pop();\n                }\n            }\n\n            private executePattern(pattern: Pattern, parentRule?: Rule, shouldBeSilent?: boolean): any {\n                switch (pattern.type) {\n                    case 'token':\n                        return this.parseToken(pattern.name, parentRule, shouldBeSilent);\n                    case 'rule':\n                        return this.parseRule(pattern.name, parentRule, shouldBeSilent);\n                    case 'repeat':\n                        return this.parseRepeat(pattern.pattern, pattern.min || 0, pattern.max || Infinity, pattern.separator, parentRule, shouldBeSilent);\n                    case 'seq':\n                        return this.parseSequence(pattern.patterns, parentRule, shouldBeSilent);\n                    case 'choice':\n                        return this.parseChoice(pattern.patterns, parentRule, shouldBeSilent);\n                    case 'optional':\n                        return this.parseOptional(pattern.pattern, parentRule);\n                    default:\n                        throw new Error(`Unknown pattern type: ${(pattern as any).type}`);\n                }\n            }\n\n            private parseToken(tokenName: string, parentRule?: Rule, shouldBeSilent?: boolean): Token | null {\n                this.lastHandledRule = parentRule?.name || tokenName;\n                this.log('tokens', `→ ${tokenName} @${this.index}`);\n                this.lastVisitedIndex = this.index;\n\n                if (this.index >= this.tokens.length) {\n                    this.log('tokens', `✗ Expected '${tokenName}', got 'EOF' @${this.index}`);\n\n                    if (shouldBeSilent) return null;\n\n                    const error = this.createError(\n                        ERRORS.TOKEN_EXPECTED_EOF,\n                        `Expected '${tokenName}', got 'EOF'`,\n                        this.getCurrentSpan(),\n                        0,\n                        this.index,\n                        this.lastHandledRule!,\n                        this.getInnerMostRule()\n                    );\n                    this.handleParseError(error, parentRule);\n                }\n\n                const token = this.getCurrentToken();\n\n                if (token.kind === tokenName) {\n                    const consumedToken = { ...token };\n                    this.index++;\n                    this.stats.tokensProcessed++;\n                    this.log('tokens', `✓ ${tokenName} = \"${token.value}\" @${this.index - 1}`);\n                    return consumedToken;\n                }\n\n                this.log('tokens', `✗ Expected '${tokenName}', got '${token.kind}' @${this.lastVisitedIndex}`);\n\n                if (shouldBeSilent) return null;\n\n                const error = this.createError(\n                    ERRORS.TOKEN_MISMATCH,\n                    `Expected '${tokenName}', got '${token.kind}'`,\n                    this.getCurrentSpan(),\n                    0,\n                    this.lastVisitedIndex,\n                    this.lastHandledRule!,\n                    this.getInnerMostRule(true)\n                );\n                this.handleParseError(error, parentRule);\n            }\n\n            protected parseRule(ruleName: string, parentRule?: Rule, shouldBeSilent?: boolean): any {\n                this.lastHandledRule = ruleName;\n                this.ruleStack.push(ruleName);\n                this.patternStack.push('rule');\n                this.lastInnerRule = ruleName;\n\n                this.log('rules', `→ ${ruleName} @${this.index} [Stack: ${this.ruleStack.join(' → ')}]`);\n                this.lastVisitedIndex = this.index;\n\n                const targetRule = this.rules.get(ruleName);\n                if (!targetRule) {\n                    this.ruleStack.pop();\n                    this.patternStack.pop();\n                    const error = new Error(`Rule '${ruleName}' not found`);\n                    this.handleFatalError(error);\n                    return null;\n                }\n\n                const startIndex = this.index;\n                const savedErrors = [...this.errors];\n                const savedSuccessfulRules = [...this.successfulRules];\n\n                try {\n                    this.stats.rulesApplied++;\n\n                    const result = this.parsePattern(targetRule.pattern, targetRule);\n\n                    if (result === null) {\n                        this.successfulRules = savedSuccessfulRules;\n\n                        if (shouldBeSilent) {\n                            this.log('rules', `✗ ${ruleName} (silent) @${this.lastVisitedIndex}`);\n                            this.ruleStack.pop();\n                            this.patternStack.pop();\n                            return null;\n                        }\n\n                        const error = this.createError(\n                            ERRORS.RULE_FAILED,\n                            `Rule '${ruleName}' failed to match`,\n                            this.getCurrentSpan(),\n                            0,\n                            this.lastVisitedIndex,\n                            this.lastHandledRule!,\n                            this.getInnerMostRule(true)\n                        );\n\n                        this.ruleStack.pop();\n                        this.patternStack.pop();\n                        this.handleParseError(error, parentRule);\n                    }\n\n                    let finalResult = result;\n                    if (result !== null && targetRule.options?.build) {\n                        finalResult = this.safeBuild(targetRule.options.build, result);\n                    }\n\n                    this.log('rules', `✓ RULE → ${ruleName} @${this.lastVisitedIndex}`);\n\n                    // Track successful completion\n                    this.lastCompletedRule = ruleName;\n                    this.successfulRules.push(ruleName);\n                    this.globalSuccessRules.push(ruleName);\n\n                    this.updateLeafRule(ruleName);\n                    this.trimSuccessfulRules();\n\n                    this.ruleStack.pop();\n                    this.patternStack.pop();\n                    return finalResult;\n\n                } catch (e) {\n                    this.successfulRules = savedSuccessfulRules;\n                    this.ruleStack.pop();\n                    this.patternStack.pop();\n\n                    if (shouldBeSilent) {\n                        this.index = startIndex;\n                        this.errors = savedErrors;\n                        return null;\n                    }\n\n                    if (e instanceof Error) {\n                        this.handleFatalError(e);\n                    } else {\n                        const error = this.createError(\n                            (e as ParseError).code,\n                            (e as ParseError).msg,\n                            (e as ParseError).span,\n                            (e as ParseError).failedAt,\n                            (e as ParseError).tokenIndex,\n                            (e as ParseError).prevRule,\n                            this.getInnerMostRule()\n                        );\n                        this.handleParseError(error, parentRule);\n                    }\n                }\n            }\n\n            private parseOptional(pattern: Pattern, parentRule?: Rule): any {\n                this.lastHandledRule = 'optional';\n                this.log('verbose', `OPTIONAL @${this.index}`);\n                this.lastVisitedIndex = this.index;\n\n                const startIndex = this.index;\n                const savedErrors = [...this.errors];\n\n                // ISSUE WAS HERE - The silent context was interfering with proper error handling\n                // We need to handle optional parsing more carefully\n\n                try {\n                    // Parse the pattern - but we need to be more careful about silent mode\n                    const result = this.parsePattern(pattern, parentRule);\n\n                    if (result !== null) {\n                        // Success case - return array with the result\n                        this.log('verbose', `✓ OPTIONAL → [1 element] @${this.index}`);\n                        return [result];\n                    } else {\n                        // Pattern returned null - this is a normal failure for optional\n                        // Reset to start position since we didn't consume anything useful\n                        this.index = startIndex;\n                        this.errors = savedErrors;\n                        this.log('verbose', `✓ OPTIONAL → [] (pattern returned null) @${this.index}`);\n                        return [];\n                    }\n                } catch (e) {\n                    // Exception thrown - reset state completely\n                    this.index = startIndex;\n                    this.errors = savedErrors;\n                    this.log('verbose', `✓ OPTIONAL → [] (exception caught: ${(e as any).msg || e}) @${this.index}`);\n                    return [];\n                }\n            }\n\n            private parseRepeat(pattern: Pattern, min = 0, max = Infinity, separator?: Pattern, parentRule?: Rule, shouldBeSilent?: boolean): any {\n                this.lastHandledRule = pattern.type;\n                this.log('verbose', `REPEAT(${min}-${max}) @${this.index}`);\n                this.lastVisitedIndex = this.index;\n\n                const results: any[] = [];\n                let consecutiveFailures = 0;\n                const startIndex = this.index;\n\n                while (results.length < max && this.index < this.tokens.length) {\n                    const iterationStart = this.index;\n                    const savedErrors = [...this.errors];\n\n                    try {\n                        const result = this.parsePattern(pattern, parentRule);\n\n                        if (result === null) {\n                            this.errors = savedErrors;\n\n                            // FIXED: Better minimum requirement handling\n                            if (results.length >= min) {\n                                // We have enough results, break cleanly\n                                break;\n                            } else if (shouldBeSilent || pattern.silent) {\n                                // Silent mode - break without error\n                                break;\n                            } else {\n                                // Not enough results and not silent - this is an error\n                                consecutiveFailures++;\n                                if (consecutiveFailures > 3) break;\n\n                                // Try recovery if we have a recovery strategy\n                                if (parentRule?.options?.recovery) {\n                                    this.applyRecovery(parentRule, iterationStart);\n                                    if (this.index === iterationStart) {\n                                        this.index++; // Force progress\n                                    }\n                                    continue;\n                                } else {\n                                    // No recovery - break and let minimum check handle the error\n                                    break;\n                                }\n                            }\n                        }\n\n                        consecutiveFailures = 0;\n                        results.push(result);\n\n                        if (this.index === iterationStart) {\n                            this.log('verbose', `⚠️ No progress in repeat iteration, breaking @${this.index}`);\n                            break;\n                        }\n\n                        // Handle separator if needed\n                        if (separator && results.length < max && this.index < this.tokens.length) {\n                            const sepStart = this.index;\n                            const sepSavedErrors = [...this.errors];\n\n                            try {\n                                const sepResult = this.parsePattern(separator, undefined);\n                                if (sepResult === null) {\n                                    this.index = sepStart;\n                                    this.errors = sepSavedErrors;\n                                    break;\n                                }\n                            } catch (e) {\n                                this.index = sepStart;\n                                this.errors = sepSavedErrors;\n                                break;\n                            }\n                        }\n\n                    } catch (e) {\n                        consecutiveFailures++;\n\n                        this.index = iterationStart;\n                        this.errors = savedErrors;\n\n                        if (shouldBeSilent || results.length >= min) {\n                            break;\n                        }\n\n                        // FIXED: Let the pattern error propagate up instead of handling it here\n                        // This allows the proper error handling in the calling context\n                        throw e;\n                    }\n                }\n\n                // FIXED: Check minimum requirement and create appropriate error\n                if (results.length < min) {\n                    if (shouldBeSilent) {\n                        return null;\n                    }\n\n                    // Check if we should use a custom error from the parent rule\n                    if (parentRule?.options?.errors) {\n                        const customError = this.getCustomErrorForCondition(parentRule, 0, this.index, startIndex);\n                        if (customError) {\n                            throw customError;\n                        }\n                    }\n\n                    const error = this.createError(\n                        ERRORS.REPEAT_MIN_NOT_MET,\n                        `Expected at least ${min} occurrences, got ${results.length}`,\n                        this.getCurrentSpan(),\n                        0,\n                        this.index,\n                        this.lastHandledRule!\n                    );\n\n                    throw error;\n                }\n\n                this.log('verbose', `REPEAT → [${results.length}] @${this.index}`);\n\n                if (results.length === 0) {\n                    return min === 0 ? [] : null;\n                }\n\n                return results.length === 1 && min === 1 && max === 1 ? results[0] : results;\n            }\n\n            private parseChoice(patterns: Pattern[], parentRule?: Rule, shouldBeSilent?: boolean): any {\n                this.log('verbose', `CHOICE[${patterns.length}] @${this.index}`);\n                this.lastVisitedIndex = this.index;\n\n                const startIndex = this.index;\n                const savedErrors = [...this.errors];\n\n                let bestResult: {\n                    index: number;\n                    errors: ParseError[];\n                    span: Span;\n                    progress: number;\n                    patternIndex: number;\n                    failedAt: number;\n                } | null = null;\n\n                for (let patternIndex = 0; patternIndex < patterns.length; patternIndex++) {\n                    this.index = startIndex;\n                    this.errors = [...savedErrors];\n\n                    try {\n                        const result = this.parsePattern(patterns[patternIndex], parentRule);\n                        if (result !== null) {\n                            this.log('verbose', `✓ CHOICE → alt ${patternIndex + 1}/${patterns.length} succeeded @${this.lastVisitedIndex}`);\n                            return result;\n                        }\n\n                        const progress = this.lastVisitedIndex - startIndex;\n                        const currentErrors = this.errors.slice(savedErrors.length);\n\n                        this.log('verbose', `✗ CHOICE → alt ${patternIndex + 1} failed, errors=${currentErrors.length}, progress=${progress}`);\n\n                        if (!bestResult || progress > bestResult.progress || (progress === bestResult.progress && currentErrors.length > 0)) {\n                            bestResult = {\n                                index: this.index,\n                                errors: currentErrors,\n                                span: this.getCurrentSpan(),\n                                progress,\n                                patternIndex,\n                                failedAt: -1\n                            };\n                        }\n                    } catch (error: any) {\n                        const progress = this.lastVisitedIndex - startIndex;\n                        const normalizedError = this.normalizeError(error, this.getCurrentSpan());\n\n                        this.log('verbose', `✗ CHOICE → alt ${patternIndex + 1} threw error: ${normalizedError.msg}, progress=${progress}`);\n\n                        if (!bestResult || (progress >= bestResult.progress && error.failedAt > bestResult.failedAt)) {\n                            bestResult = {\n                                index: this.lastVisitedIndex,\n                                errors: [normalizedError],\n                                span: normalizedError.span,\n                                progress,\n                                patternIndex,\n                                failedAt: normalizedError.failedAt || -1\n                            };\n                        }\n                    }\n                }\n\n                // All alternatives failed\n                this.index = startIndex;\n                this.errors = savedErrors;\n\n                if (shouldBeSilent) return null;\n\n                if (bestResult) {\n                    const bestError = bestResult.errors.length > 0\n                        ? bestResult.errors[bestResult.errors.length - 1]\n                        : this.createError(\n                            ERRORS.CHOICE_ALL_FAILED,\n                            `Choice failed at alternative ${this.lastVisitedIndex + 1}`,\n                            bestResult.span,\n                            bestResult.failedAt,\n                            this.lastVisitedIndex,\n                            this.lastHandledRule!\n                        );\n\n                    this.log('verbose', `✗ All alternatives failed. Best: pattern ${this.lastVisitedIndex}, progress ${bestResult.progress}, failedAt ${bestResult.failedAt}, error: ${bestError.msg}`);\n                    throw bestError;\n                }\n\n                const error = this.createError(\n                    ERRORS.CHOICE_ALL_FAILED,\n                    `Expected one of: ${patterns.map(p => this.patternToString(p)).join(', ')}`,\n                    this.getCurrentSpan(),\n                    0,\n                    this.lastVisitedIndex,\n                    this.lastHandledRule!\n                );\n                throw error;\n            }\n\n            private parseSequence(patterns: Pattern[], parentRule?: Rule, shouldBeSilent?: boolean): any {\n                this.log('verbose', `SEQUENCE[${patterns.length}] @${this.index}`);\n                this.lastVisitedIndex = this.index;\n\n                if (patterns.length === 0) return [];\n\n                const startIndex = this.index;\n                const savedErrors = [...this.errors];\n                const results: any[] = [];\n                let lastPatternIndex = 0;\n\n                try {\n                    for (lastPatternIndex = 0; lastPatternIndex < patterns.length; lastPatternIndex++) {\n                        const pattern = patterns[lastPatternIndex];\n                        const beforePatternIndex = this.index;\n\n                        const result = this.parsePattern(pattern, parentRule);\n\n                        if (result === null) {\n                            if (shouldBeSilent) {\n                                this.index = startIndex;\n                                this.errors = savedErrors;\n                                return null;\n                            }\n\n                            const error = this.createError(\n                                ERRORS.SEQUENCE_FAILED,\n                                `Sequence failed at element ${lastPatternIndex + 1}/${patterns.length}`,\n                                this.getCurrentSpan(),\n                                lastPatternIndex,\n                                this.lastVisitedIndex,\n                                this.lastHandledRule!\n                            );\n\n                            this.handleParseError(error, parentRule);\n                        }\n\n                        results.push(result);\n\n                        if (this.index === beforePatternIndex && !pattern.silent) {\n                            this.log('verbose', `⚠️  No progress at sequence element ${lastPatternIndex} @${this.lastVisitedIndex}`);\n                        }\n\n                        this.skipIgnored(parentRule?.options?.ignored);\n                    }\n\n                    this.log('verbose', `SEQUENCE → [${results.length}] @${this.lastVisitedIndex}`);\n                    return results;\n\n                } catch (e) {\n                    this.index = startIndex;\n                    this.errors = savedErrors;\n\n                    if (!shouldBeSilent && !this.isInSilentMode()) {\n                        if (e instanceof Error) {\n                            this.handleFatalError(e);\n                        } else {\n                            const error = this.createError((e as ParseError).code, (e as ParseError).msg, (e as ParseError).span, lastPatternIndex, this.lastVisitedIndex, this.lastHandledRule!);\n                            this.handleParseError(error, parentRule);\n                        }\n                    }\n\n                    return null;\n                }\n            }\n\n            private safeBuild(buildFn: Function, matches: any): any {\n                try {\n                    const input = Array.isArray(matches) ? matches : [matches];\n                    return buildFn(input);\n                } catch (error) {\n                    if (!this.isInSilentMode()) {\n                        console.error(`Build function failed: ${JSON.stringify(matches, null, 2)}, lastVisitedIndex: ${this.lastVisitedIndex}, lastHandledRule: ${this.lastHandledRule}`);\n                        const buildError = this.createError(\n                            ERRORS.BUILD_FUNCTION_FAILED,\n                            `Build function failed: ${(error as Error).message}`,\n                            this.getCurrentSpan(),\n                            0,\n                            this.lastVisitedIndex,\n                            this.lastHandledRule!\n                        );\n                        this.addError(buildError);\n                        this.log('errors', `Build error: ${(error as Error).message}`);\n                    }\n                    return matches;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MODE ──────────────────────────────┐\n\n            private shouldBeSilent(pattern: Pattern, rule?: Rule): boolean {\n                return rule?.options?.silent === true ||\n                    pattern.silent === true ||\n                    (this.silentContextStack.length > 0 && this.silentContextStack[this.silentContextStack.length - 1]);\n            }\n\n            private isInSilentMode(): boolean {\n                return this.silentContextStack.length > 0 &&\n                    this.silentContextStack[this.silentContextStack.length - 1];\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            private normalizeSettings(settings?: ParserSettings): ParserSettings {\n                const defaultSettings: ParserSettings = {\n                    startRule       : 'root',\n                    errorRecovery   : {\n                        mode        : 'strict',\n                        maxErrors   : 1,\n                    },\n                    ignored         : ['ws'],\n                    debug           : 'off',\n                    maxDepth        : 1000,\n                    maxCacheSize    : 1, // 1 MB\n                };\n\n                if (!settings) return defaultSettings;\n\n                const mergedSettings = { ...defaultSettings, ...settings };\n                if (settings?.errorRecovery) {\n                    mergedSettings.errorRecovery = { ...defaultSettings.errorRecovery, ...settings.errorRecovery };\n                }\n\n                return mergedSettings;\n            }\n\n            private validateGrammar(): string[] {\n                const issues: string[] = [];\n                const ruleNames = new Set(Array.from(this.rules.keys()));\n\n                for (const [ruleName, rule] of this.rules) {\n                    const referencedRules = this.extractRuleReferences(rule.pattern);\n                    for (const ref of referencedRules) {\n                        if (!ruleNames.has(ref)) {\n                            issues.push(`Rule '${ruleName}' references undefined rule '${ref}'`);\n                        }\n                    }\n                }\n\n                if (!this.rules.has(this.settings.startRule)) {\n                    issues.push(`Start rule '${this.settings.startRule}' is not defined`);\n                }\n\n                return issues;\n            }\n\n            private extractRuleReferences(pattern: Pattern): string[] {\n                const refs: string[] = [];\n\n                switch (pattern.type) {\n                    case 'rule':\n                        refs.push(pattern.name);\n                        break;\n                    case 'repeat':\n                        refs.push(...this.extractRuleReferences(pattern.pattern));\n                        if (pattern.separator) {\n                            refs.push(...this.extractRuleReferences(pattern.separator));\n                        }\n                        break;\n                    case 'optional':\n                        refs.push(...this.extractRuleReferences(pattern.pattern));\n                        break;\n                    case 'seq':\n                    case 'choice':\n                        if (pattern.patterns) {\n                            for (const p of pattern.patterns) {\n                                refs.push(...this.extractRuleReferences(p));\n                            }\n                        }\n                        break;\n                }\n\n                return refs;\n            }\n\n            private skipIgnored(ruleIgnored?: string[]): void {\n                if (this.ignoredSet.size === 0 && (!ruleIgnored?.length)) return;\n\n                const combinedIgnored = ruleIgnored\n                    ? new Set([...this.ignoredSet, ...ruleIgnored])\n                    : this.ignoredSet;\n\n                while (this.index < this.tokens.length) {\n                    const token = this.tokens[this.index];\n                    if (!combinedIgnored.has(token.kind)) break;\n                    this.index++;\n                    this.stats.tokensProcessed++;\n                }\n            }\n\n            private skipUntilTokens(tokens: string[]): void {\n                if (tokens.length === 0) return;\n\n                const tokenSet = new Set(tokens);\n                const maxIterations = Math.min(10000, this.tokens.length - this.index);\n                let skipped = 0;\n\n                while (this.index < this.tokens.length && skipped < maxIterations) {\n                    const currentToken = this.tokens[this.index];\n\n                    if (tokenSet.has(currentToken.kind)) {\n                        this.log('errors', `Found sync token '${currentToken.kind}' @${this.index}`);\n                        return;\n                    }\n                    this.index++;\n                    skipped++;\n                }\n            }\n\n            private deepClone(obj: any): any {\n                if (obj === null || typeof obj !== 'object') return obj;\n                if (Array.isArray(obj)) return obj.map(item => this.deepClone(item));\n\n                if (obj.type || obj.span || obj.value) {\n                    const cloned: any = {};\n                    for (const [key, value] of Object.entries(obj)) {\n                        cloned[key] = this.deepClone(value);\n                    }\n                    return cloned;\n                }\n\n                return obj;\n            }\n\n            private resetState(tokens: Token[]): void {\n                this.tokens = tokens;\n                this.index = 0;\n                this.errors = [];\n                this.ast = [];\n                this.depth = 0;\n                this.errorSeq = 0;\n                this.indentLevel = 0;\n                this.silentContextStack = [];\n\n                // Reset enhanced rule tracking\n                this.ruleStack = [];\n                this.patternStack = [];\n                this.lastInnerRule = 'unknown';\n                this.lastCompletedRule = 'unknown';\n                this.successfulRules = [];\n                this.globalSuccessRules = [];\n                this.lastLeafRule = 'unknown';\n\n                // Reset memoization\n                this.memoCache.clear();\n                this.memoHits = 0;\n                this.memoMisses = 0;\n\n                this.stats = {\n                    tokensProcessed: 0,\n                    rulesApplied: 0,\n                    errorsRecovered: 0,\n                    parseTimeMs: 0\n                };\n            }\n\n            private getCurrentToken(): Token {\n                return this.tokens[this.index];\n            }\n\n            private getCurrentSpan(): Span {\n                if (this.index === 0) {\n                    if (this.tokens.length > 0) {\n                        return {\n                            start: this.tokens[0].span.start,\n                            end: this.tokens[0].span.start\n                        };\n                    }\n                    return { start: 0, end: 0 };\n                }\n\n                if (this.index >= this.tokens.length) {\n                    const lastToken = this.tokens[this.tokens.length - 1];\n                    return {\n                        start: lastToken.span.end,\n                        end: lastToken.span.end\n                    };\n                }\n\n                return this.tokens[this.index].span;\n            }\n\n            private patternToString(pattern: Pattern): string {\n                switch (pattern.type) {\n                    case 'token': return `'${pattern.name}'`;\n                    case 'rule': return pattern.name;\n                    case 'repeat': return `${this.patternToString(pattern.pattern)}...`;\n                    case 'optional': return `${this.patternToString(pattern.pattern)}?`;\n                    case 'choice': return `choice(${pattern.patterns.map((p: any) => this.patternToString(p)).join('|')})`;\n                    case 'seq': return `seq(${pattern.patterns.map((p: any) => this.patternToString(p)).join(' ')})`;\n                    default: return pattern.type;\n                }\n            }\n\n            private updateLeafRule(ruleName: string): void {\n                if (ruleName !== 'unknown' &&\n                    !ruleName.includes('<') &&\n                    !ruleName.includes('→') && (ruleName.length < 30) &&\n                    !['Statement', 'VariableDeclaration', 'let <mut> name;'].includes(ruleName)) {\n                    this.lastLeafRule = ruleName;\n                    this.log('verbose', `🍃 Updated lastLeafRule to: \"${ruleName}\"`);\n                }\n            }\n\n            private trimSuccessfulRules(): void {\n                if (this.successfulRules.length > 10) {\n                    this.successfulRules = this.successfulRules.slice(-5);\n                }\n                if (this.globalSuccessRules.length > 20) {\n                    this.globalSuccessRules = this.globalSuccessRules.slice(-10);\n                }\n            }\n\n            isNextToken(type: string, ignoredTokens?: string[]): boolean {\n                const ignored = [...(ignoredTokens ?? []), ...this.settings.ignored!];\n                let currentIndex = this.index;\n\n                while (currentIndex < this.tokens.length) {\n                    const currentToken = this.tokens[currentIndex];\n                    if (currentToken.kind === type) return true;\n                    if (ignored.includes(currentToken.kind)) {\n                        currentIndex++;\n                    } else {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            isPrevToken(type: string, startIndex: number = -1, ignoredTokens?: string[]): boolean {\n                if (startIndex === -1) startIndex = this.index > 0 ? this.index : 0;\n                const ignored = [...(ignoredTokens ?? []), ...this.settings.ignored!];\n                let currentIndex = startIndex - 1;\n\n                while (currentIndex >= 0) {\n                    const currentToken = this.tokens[currentIndex];\n                    if (currentToken.kind === type) return true;\n                    if (ignored.includes(currentToken.kind)) {\n                        currentIndex--;\n                    } else {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            isPrevRule(name: string): boolean {\n                console.warn(`isPrevRule: ${JSON.stringify(this.lastHandledRule, null, 2)}`);\n                return this.lastHandledRule === name;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── ERROR ──────────────────────────────┐\n\n            private createError(code: number, msg: string, span: Span | undefined, failedAt: number, tokenIndex: number, prevRule: string, prevInnerRule?: string): ParseError {\n                return {\n                    code,\n                    msg,\n                    span: span || this.getCurrentSpan(),\n                    failedAt,\n                    tokenIndex,\n                    prevRule,\n                    prevInnerRule: prevInnerRule || this.getInnerMostRule()\n                };\n            }\n\n            private getCustomErrorOr(rule: Rule | null | undefined, defaultError: ParseError): ParseError {\n                if (!rule?.options?.errors) return defaultError;\n\n                for (const errorHandler of rule.options.errors) {\n                    let matches = false;\n\n                    if (typeof errorHandler.cond === 'number') {\n                        matches = (defaultError.failedAt === errorHandler.cond);\n                    } else if (typeof errorHandler.cond === 'function') {\n                        try {\n                            const contextualInnerRule = this.getInnerMostRule(true);\n\n                            const opt = {\n                                failedAt: defaultError.failedAt,\n                                tokenIndex: defaultError.tokenIndex,\n                                prevRule: defaultError.prevRule,\n                                prevInnerRule: contextualInnerRule\n                            };\n\n                            matches = errorHandler.cond(this, opt);\n                        } catch (err) {\n                            console.error('Error in condition function:', err);\n                            matches = false;\n                        }\n                    }\n\n                    if (matches) {\n                        return this.createError(\n                            errorHandler.code || ERRORS.CUSTOM_ERROR,\n                            errorHandler.msg,\n                            defaultError.span,\n                            defaultError.failedAt,\n                            defaultError.tokenIndex,\n                            defaultError.prevRule,\n                            defaultError.prevInnerRule || this.getInnerMostRule(true)\n                        );\n                    }\n                }\n\n                return defaultError;\n            }\n\n            private getInnerMostRule(forErrorCondition = false): string {\n                this.log('verbose', `📍 Rule context: stack=[${this.ruleStack.join(',')} as ${this.patternStack.join(',')}], recent=[${this.successfulRules.slice(-3).join(',')}], leaf=${this.lastLeafRule}, current=${this.lastHandledRule}`);\n\n                if (forErrorCondition && this.lastLeafRule !== 'unknown') {\n                    this.log('verbose', `🎯 getInnerMostRule(forErrorCondition=true) using lastLeafRule: \"${this.lastLeafRule}\"`);\n                    return this.lastLeafRule;\n                }\n\n                if (this.ruleStack.length > 0) {\n                    return this.ruleStack[this.ruleStack.length - 1];\n                }\n\n                if (this.lastLeafRule !== 'unknown') {\n                    return this.lastLeafRule;\n                }\n\n                // Look at most recently completed meaningful rule\n                const meaningfulRules = [...this.successfulRules, ...this.globalSuccessRules];\n                for (let i = meaningfulRules.length - 1; i >= 0; i--) {\n                    const rule = meaningfulRules[i];\n                    if (this.isMeaningfulRule(rule)) {\n                        return rule;\n                    }\n                }\n\n                if (this.lastCompletedRule !== 'unknown' && this.lastCompletedRule.length < 30) {\n                    return this.lastCompletedRule;\n                }\n\n                return this.lastInnerRule;\n            }\n\n            private isMeaningfulRule(rule: string): boolean {\n                return rule !== 'unknown' &&\n                    !rule.includes('<') &&\n                    !rule.includes('→') &&\n                    rule.length < 30 &&\n                    !['Statement', 'VariableDeclaration'].includes(rule);\n            }\n\n            private addError(error: ParseError): void {\n                if (this.isInSilentMode()) return;\n\n                const maxErrors = this.settings.errorRecovery!.maxErrors!;\n                if (maxErrors !== 0 && this.errors.length >= maxErrors) return;\n\n                if (this.settings.errorRecovery!.mode === 'strict' && this.errors.length > 0) return;\n\n                this.errors.push(error);\n                this.log('errors', `⚠️  ${error.msg} @${error.span.start}:${error.span.end}`);\n            }\n\n            private handleParseError(error: ParseError, rule?: Rule): never {\n                const finalError = this.getCustomErrorOr(rule, error);\n                throw finalError;\n            }\n\n            private handleFatalError(error: any): void {\n                const parseError = this.normalizeError(error, this.getCurrentSpan());\n                parseError.prevInnerRule = this.getInnerMostRule();\n                this.addError(parseError);\n                this.log('errors', `💥 Fatal error: ${parseError.msg} @${this.index}`);\n            }\n\n            private normalizeError(error: any, defaultSpan: Span): ParseError {\n                if (error && typeof error === 'object' && 'msg' in error && 'code' in error && 'span' in error) {\n                    const parseError = error as ParseError;\n                    if (!parseError.prevInnerRule) {\n                        parseError.prevInnerRule = this.getInnerMostRule();\n                    }\n                    return parseError;\n                }\n\n                if (error instanceof Error) {\n                    return this.createError(\n                        ERRORS.FATAL_ERROR,\n                        error.message,\n                        defaultSpan,\n                        0,\n                        this.lastVisitedIndex,\n                        this.lastHandledRule!,\n                        this.getInnerMostRule()\n                    );\n                }\n\n                return this.createError(\n                    ERRORS.UNKNOWN_ERROR,\n                    `Unknown error: ${error}`,\n                    defaultSpan,\n                    0,\n                    this.lastVisitedIndex,\n                    this.lastHandledRule!,\n                    this.getInnerMostRule()\n                );\n            }\n\n            private applyRecovery(rule?: Rule, startIndex?: number): void {\n                const recovery = rule?.options?.recovery;\n\n                if (recovery) {\n                    this.applyRecoveryStrategy(recovery);\n                } else {\n                    // FIXED: Only apply default recovery if no custom recovery is defined\n                    this.skipIgnored();\n                    if (this.index < this.tokens.length) {\n                        this.index++;\n                    }\n                }\n\n                this.stats.errorsRecovered++;\n\n                // Ensure we make progress\n                if (startIndex !== undefined && this.index === startIndex && this.index < this.tokens.length) {\n                    this.index++;\n                }\n            }\n\n            private getCustomErrorForCondition(rule: Rule, failedAt: number, tokenIndex: number, startIndex: number): ParseError | null {\n                if (!rule?.options?.errors) return null;\n\n                for (const errorHandler of rule.options.errors) {\n                    let matches = false;\n\n                    if (typeof errorHandler.cond === 'number') {\n                        matches = (failedAt === errorHandler.cond);\n                    } else if (typeof errorHandler.cond === 'function') {\n                        try {\n                            const opt = {\n                                failedAt,\n                                tokenIndex,\n                                prevRule: rule.name,\n                                prevInnerRule: this.getInnerMostRule(true)\n                            };\n                            matches = errorHandler.cond(this, opt);\n                        } catch (err) {\n                            console.error('Error in condition function:', err);\n                            matches = false;\n                        }\n                    }\n\n                    if (matches) {\n                        return this.createError(\n                            errorHandler.code || ERRORS.CUSTOM_ERROR,\n                            errorHandler.msg,\n                            this.getCurrentSpan(),\n                            failedAt,\n                            tokenIndex,\n                            rule.name,\n                            this.getInnerMostRule(true)\n                        );\n                    }\n                }\n\n                return null;\n            }\n\n            private applyRecoveryStrategy(strategy: RecoveryStrategy): void {\n                const beforePos = this.index;\n                this.log('errors', `🔧 Recovery: ${strategy.type} @${beforePos}`);\n\n                switch (strategy.type) {\n                    case 'skipUntil':\n                        const tokens = strategy.tokens || (strategy.token ? [strategy.token] : []);\n                        this.skipUntilTokens(tokens);\n                        break;\n                    default:\n                }\n\n                this.log('errors', `Recovery: ${beforePos} → ${this.index}`);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── DEBUG ──────────────────────────────┐\n\n            private log(level: DebugLevel, message: string): void {\n                if (this.debugLevel === 'off') return;\n\n                const levels: DebugLevel[] = ['off', 'errors', 'rules', 'patterns', 'tokens', 'verbose'];\n                const currentIndex = levels.indexOf(this.debugLevel);\n                const messageIndex = levels.indexOf(level);\n\n                if (messageIndex <= currentIndex) {\n                    const prefix = this.getDebugPrefix(level);\n                    console.log(`${prefix} ${message}`);\n                }\n            }\n\n            private getDebugPrefix(level: DebugLevel): string {\n                const prefixes: Record<string, string> = {\n                    errors      : '🔥',\n                    rules       : '📋',\n                    patterns    : '🔍',\n                    tokens      : '🎯',\n                    verbose     : '📝'\n                };\n\n                return `[${prefixes[level] || (level === 'off' ? '⚡' : '')}]`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── CACHE ──────────────────────────────┐\n\n            public dispose(): void {\n                this.memoCache.clear();\n                this.rules.clear();\n                this.ignoredSet.clear();\n                this.tokens = [];\n                this.ast = [];\n                this.errors = [];\n                this.silentContextStack = [];\n                this.ruleStack = [];\n                this.successfulRules = [];\n                this.globalSuccessRules = [];\n            }\n\n            private cleanMemoCache(): void {\n                const entries = Array.from(this.memoCache.entries());\n                const now = Date.now();\n\n                const validEntries = entries.filter(([, value]) => {\n                    if (now - (value.cachedAt || 0) > 1000) return false;\n                    if (value.errorCount !== this.errors.length) return false;\n                    return true;\n                });\n\n                const keepCount = Math.floor(validEntries.length / 2);\n                this.memoCache.clear();\n\n                for (let i = validEntries.length - keepCount; i < validEntries.length; i++) {\n                    this.memoCache.set(validEntries[i][0], validEntries[i][1]);\n                }\n\n                this.log('verbose', `🧹 Memo cache cleaned: kept ${keepCount} of ${entries.length} entries`);\n            }\n\n            private createMemoKey(patternType: string, patternData: any, position: number, ruleName?: string): string {\n                const silentContext = this.isInSilentMode() ? 'S' : 'L';\n                const errorContext = this.errors.length > 0 ? `E${this.errors.length}` : 'E0';\n                const baseKey = `${patternType}:${position}:${silentContext}:${errorContext}`;\n\n                if (ruleName) {\n                    const rule = this.rules.get(ruleName);\n                    const ruleContext = this.getRuleContext(rule);\n                    return `rule:${ruleName}:${ruleContext}:${baseKey}`;\n                }\n\n                switch (patternType) {\n                    case 'token':\n                        return `${baseKey}:${patternData.name}`;\n                    case 'optional':\n                        return `${baseKey}:optional`;\n                    case 'repeat':\n                        return `${baseKey}:${patternData.min || 0}:${patternData.max || 'inf'}:${patternData.separator ? 'sep' : 'nosep'}`;\n                    case 'seq':\n                    case 'choice':\n                        const patternHash = this.hashPatterns(patternData.patterns || []);\n                        return `${baseKey}:${patternData.patterns?.length || 0}:${patternHash}`;\n                    default:\n                        return baseKey;\n                }\n            }\n\n            private getRuleContext(rule?: Rule): string {\n                if (!rule) return 'none';\n\n                const hasBuilder = rule.options?.build ? 'B' : '';\n                const hasErrors = rule.options?.errors?.length ? 'E' : '';\n                const hasRecovery = rule.options?.recovery ? 'R' : '';\n                const isSilent = rule.options?.silent ? 'S' : '';\n\n                return `${hasBuilder}${hasErrors}${hasRecovery}${isSilent}`;\n            }\n\n            private hashPatterns(patterns: Pattern[]): string {\n                return patterns.map(p => `${p.type}${p.silent ? 'S' : ''}`).join('');\n            }\n\n            private getMemoized(key: string): { hit: boolean; result?: any; newIndex?: number } {\n                if (!this.settings.maxCacheSize || this.memoCache.size >= this.settings.maxCacheSize) {\n                    return { hit: false };\n                }\n\n                const cached = this.memoCache.get(key);\n                if (cached !== undefined) {\n                    if (this.isCachedResultValid(cached)) {\n                        this.memoHits++;\n                        this.log('verbose', `📋 Memo HIT: ${key} → ${cached.newIndex}`);\n                        return { hit: true, result: cached.result, newIndex: cached.newIndex };\n                    } else {\n                        this.memoCache.delete(key);\n                        this.log('verbose', `🗑️ Memo INVALID: ${key}`);\n                    }\n                }\n\n                this.memoMisses++;\n                return { hit: false };\n            }\n\n            private isCachedResultValid(cached: any): boolean {\n                if (typeof cached.newIndex !== 'number' || cached.newIndex < 0) return false;\n                if (cached.newIndex > this.tokens.length) return false;\n                return true;\n            }\n\n            private memoize(key: string, result: any, startIndex: number, endIndex: number): void {\n                if (!this.settings.maxCacheSize || this.memoCache.size >= this.settings.maxCacheSize) return;\n\n                if (result === null && startIndex === endIndex) {\n                    this.log('verbose', `⚠️ Skip memo (no progress): ${key}`);\n                    return;\n                }\n\n                if (this.errors.length > 0 && this.stats.errorsRecovered > 0) {\n                    this.log('verbose', `⚠️ Skip memo (error state): ${key}`);\n                    return;\n                }\n\n                if (this.memoCache.size >= (this.settings.maxCacheSize * 0.9)) {\n                    this.cleanMemoCache();\n                }\n\n                const memoEntry = {\n                    result: this.deepClone(result),\n                    newIndex: endIndex,\n                    cachedAt: Date.now(),\n                    silentContext: this.isInSilentMode(),\n                    errorCount: this.errors.length\n                };\n\n                this.memoCache.set(key, memoEntry);\n                this.log('verbose', `💾 Memo SET: ${key} → ${endIndex}`);\n            }\n\n            private shouldUseMemoization(pattern: Pattern, parentRule?: Rule): boolean {\n                if (this.stats.errorsRecovered > 0 && this.errors.length > 0) return false;\n                if (pattern.type === 'token') return false;\n                if (pattern.type === 'rule' && this.isRecursiveContext()) return false;\n\n                return pattern.type === 'rule' ||\n                    pattern.type === 'choice' ||\n                    pattern.type === 'seq' ||\n                    pattern.type === 'optional' ||\n                    (pattern.type === 'repeat' && (pattern.min > 1 || pattern.max > 1));\n            }\n\n            private isRecursiveContext(): boolean {\n                return this.depth > 10;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ MAIN ════════════════════════════════════════╗\n\n    export function parse(tokens: Token[], rules: Rules, settings?: ParserSettings): ParseResult {\n        const parser = new Parser(rules, settings);\n        try {\n            return parser.parse(tokens);\n        } finally {\n            parser.dispose();\n        }\n    }\n\n    export const createRule = ( name: string, pattern: Pattern, options: Rule['options'] = {} ): Rule => {\n        const finalOptions = { name, silent: false, ...options, };\n        return { name, pattern: pattern, options: finalOptions, };\n    };\n\n    // ●●●● Pattern Combinators ●●●●\n\n    export function token(name: string, silent: boolean = false): Pattern {\n        if (!name || typeof name !== 'string') {\n            throw new Error('Token name must be a non-empty string');\n        }\n        return { type: 'token', name, silent };\n    }\n\n    export function rule(name: string, silent: boolean = false): Pattern {\n        if (!name || typeof name !== 'string') {\n            throw new Error('Rule name must be a non-empty string');\n        }\n        return { type: 'rule', name, silent };\n    }\n\n    export function repeat(pattern: Pattern, min = 0, max = Infinity, separator?: Pattern, silent: boolean = false): Pattern {\n        if (min < 0) {\n            throw new Error('Minimum repetition count cannot be negative');\n        }\n        if (max < min) {\n            throw new Error('Maximum repetition count cannot be less than minimum');\n        }\n        return { type: 'repeat', pattern, min, max, separator, silent };\n    }\n\n    export function oneOrMore(pattern: Pattern, separator?: Pattern, silent: boolean = false): Pattern {\n        return repeat(pattern, 1, Infinity, separator, silent);\n    }\n\n    export function zeroOrMore(pattern: Pattern, separator?: Pattern, silent: boolean = false): Pattern {\n        return repeat(pattern, 0, Infinity, separator, silent);\n    }\n\n    export function zeroOrOne(pattern: Pattern, separator?: Pattern, silent: boolean = true): Pattern {\n        return repeat(pattern, 0, 1, separator, silent);\n    }\n\n    export function optional(pattern: Pattern, silent: boolean = false): Pattern {\n        if (!pattern || typeof pattern !== 'object') {\n            throw new Error('Optional pattern must be a valid pattern');\n        }\n        return { type: 'optional', pattern, silent };\n    }\n\n    export function choice(...patterns: Pattern[]): Pattern {\n        if (patterns.length === 0) {\n            throw new Error('Choice must have at least one pattern');\n        }\n        return { type: 'choice', patterns, silent: false };\n    }\n\n    export function seq(...patterns: Pattern[]): Pattern {\n        if (patterns.length === 0) {\n            throw new Error('Sequence must have at least one pattern');\n        }\n        return { type: 'seq', patterns, silent: false };\n    }\n\n    // ●●●● Silent Mode Helpers ●●●●\n\n    export function silent<T extends Pattern>(pattern: T): T {\n        return { ...pattern, silent: true };\n    }\n\n    export function loud<T extends Pattern>(pattern: T): T {\n        return { ...pattern, silent: false };\n    }\n\n    // ●●●● Error Handling ●●●●\n\n    export function error(cond: ErrorHandler['cond'], msg: string, code?: number): ErrorHandler {\n        return { cond, msg, code: code ?? ERRORS.RECOVERY_CUSTOM };\n    }\n\n    export const errorRecoveryStrategies = {\n        skipUntil(tokens: string | string[]): RecoveryStrategy {\n            return { type: 'skipUntil', tokens: Array.isArray(tokens) ? tokens : [tokens] };\n        },\n    };\n\n    // ●●●● Helpers ●●●●\n\n    export function getMatchesSpan(matches: any[]): Span {\n        const default_span = { start: 0, end: 0 };\n        if (!matches || matches.length === 0) return default_span;\n\n        let firstSpan: Span | null = null;\n        let lastSpan: Span | null = null;\n\n        for (const match of matches) {\n            if (match && match.span) {\n                if (!firstSpan) {\n                    firstSpan = match.span;\n                }\n                lastSpan = match.span;\n            }\n        }\n\n        if (firstSpan && lastSpan) {\n            return {\n                start: firstSpan.start,\n                end: lastSpan.end\n            };\n        }\n\n        if (firstSpan) {\n            return firstSpan;\n        }\n\n        return default_span;\n    }\n\n    export function resWithoutSpan(res: any): any {\n        const result = { ...res };\n        delete result.span;\n        return result;\n    }\n\n    export function isOptionalPassed(res: any[]) : boolean {\n        return res.length > 0;\n    }\n\n    export function getOptional(res: any[], ret: any = undefined, index: number = 0) : any {\n        if(!isOptionalPassed(res)) return ret;\n        return res[index];\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":"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","names":["rule","token","error","silent"]}