{"version":3,"sources":["../lib/parser.ts"],"sourcesContent":["// parser.ts — Advanced syntax analyzer that converts tokens\n//             into AST with customizable grammar rules and intelligent error detection.\n//\n// repo   : https://github.com/je-es/parser\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    /** Represents a token with type, value and position information */\n    export interface Token {\n        type            : string;\n        value           : string | null;\n        pos             : Position;\n    }\n\n    /** Represents a position in the source text */\n    export interface Position {\n        line            : number;\n        col             : number;\n        offset          : number;\n    }\n\n    export interface ParseError {\n        message         : string;\n        position        : Position;\n        suggestions    ?: string[];\n        context        ?: string;\n        severity       ?: 'error' | 'warning' | 'info';\n        code           ?: string;\n        range          ?: { start: Position; end: Position };\n    }\n\n    export interface AstNode {\n        type            : string;\n        pos            ?: Position;\n        child          ?: AstNode[];\n        value          ?: string | number | boolean | null;\n        meta           ?: Record<string, unknown>;\n    }\n\n    export interface ParseResult {\n        ast             : AstNode[];\n        errors          : ParseError[];\n        statistics     ?: ParseStatistics;\n    }\n\n    export interface ParseStatistics {\n        tokensProcessed : number;\n        rulesApplied    : number;\n        errorsRecovered : number;\n        parseTimeMs     : number;\n        memoryUsedKB   ?: number;\n        cacheHitRate   ?: number;\n    }\n\n    export interface ParserSettings {\n        startRule       : string;\n        errorRecovery   : {\n            mode        : 'strict' | 'resilient';\n            maxErrors   : number;\n            syncTokens  : string[];\n        };\n        ignored         : string[];\n        debug           : boolean;\n        maxDepth        : number;\n        enableMemoization: boolean;\n        maxCacheSize    : number;\n        enableProfiling : boolean;\n    }\n\n    export interface Pattern {\n        type            : 'token' | 'rule' | 'seq' | 'choice' | 'repeat' | 'optional';\n        [key: string]   : any;\n    }\n\n    export interface Rule {\n        name            : string;\n        pattern         : Pattern;\n        options        ?: {\n            build      ?: (matches: any[]) => any;\n            errors     ?: ErrorHandler[];\n            recovery   ?: RecoveryStrategy;\n            ignored    ?: string[];\n            memoizable ?: boolean;\n        };\n    }\n\n    export type Rules = Rule[];\n\n    export interface ErrorHandler {\n        condition       : (parser: Parser, failedAt: number) => boolean;\n        message         : string;\n        suggestions     : string[];\n        code           ?: string;\n        severity       ?: 'error' | 'warning' | 'info';\n    }\n\n    export interface RecoveryStrategy {\n        type            : 'panic' | 'skipUntil' | 'insertToken' | 'deleteToken';\n        tokens         ?: string[];\n        token          ?: string;\n        insertValue    ?: string;\n    }\n\n    interface MemoEntry {\n        result          : any;\n        endPosition     : number;\n        errors          : ParseError[];\n        timestamp       : number;\n    }\n\n    interface LoopDetectionState {\n        visitedPositions: Set<number>;\n        iterationCount  : number;\n        lastProgress    : number;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Parser {\n        private tokens      : Token[]                       = [];\n        private ast         : AstNode[]                     = [];\n        private position    : number                        = 0;\n        private rules       : Map<string, Rule>;\n        private settings    : ParserSettings;\n        private depth       : number                        = 0;\n        public errors       : ParseError[]                  = [];\n\n        // Performance optimizations\n        private memoCache   : Map<string, MemoEntry>        = new Map();\n        private nodePool    : AstNode[]                     = [];\n        private ignoredSet  : Set<string>                   = new Set();\n        private ruleSet     : Set<string>                   = new Set();\n\n        // Statistics and profiling\n        private stats       : ParseStatistics;\n        private startTime   : number                        = 0;\n        private cacheHits   : number                        = 0;\n        private cacheMisses : number                        = 0;\n\n        // Safety and robustness\n        private maxIterations: number                       = 10000;\n        private disposed    : boolean                       = false;\n\n        constructor(rules: Rule[], settings: ParserSettings) {\n            this.validateInput(rules, settings);\n\n            this.rules = new Map();\n            for (const rule of rules) {\n                this.rules.set(rule.name, rule);\n                this.ruleSet.add(rule.name);\n            }\n\n            this.settings = this.normalizeSettings(settings);\n            this.ignoredSet = new Set([...this.settings.ignored]);\n            this.errors = [];\n\n            this.stats = {\n                tokensProcessed: 0,\n                rulesApplied: 0,\n                errorsRecovered: 0,\n                parseTimeMs: 0\n            };\n\n            // Validate grammar\n            const grammarIssues = this.validateGrammar();\n            if (grammarIssues.length > 0) {\n                throw new Error(`Grammar validation failed: ${grammarIssues.join(', ')}`);\n            }\n        }\n\n        // ════ Main ════\n\n        /**\n         * Parses an array of tokens into an AST using the configured grammar rules.\n         * @param tokens Array of tokens to parse\n         * @returns ParseResult containing the AST and any parsing errors\n         */\n        parse(tokens: Token[]): ParseResult {\n            if (this.disposed) {\n                throw new Error('Parser has been disposed and cannot be reused');\n            }\n\n            this.startTime = Date.now();\n            this.debug(`Starting parse with ${tokens.length} tokens`);\n\n            this.resetState(tokens);\n\n            if (tokens.length === 0) {\n                return this.createResult();\n            }\n\n            try {\n                const startRule = this.rules.get(this.settings.startRule);\n                if (!startRule) {\n                    throw new Error(`Start rule '${this.settings.startRule}' not found`);\n                }\n\n                this.skipIgnored();\n                const result = this.parsePattern(startRule.pattern, startRule);\n\n                if (result !== null) {\n                    // Apply build function if available\n                    if (startRule.options?.build) {\n                        const processed = this.safeBuild(startRule.options.build, result);\n                        if (processed !== null) {\n                            this.ast.push(processed);\n                        }\n                    } else {\n                        this.ast.push(result);\n                    }\n                }\n\n                // Check if there are unparsed tokens (unless in resilient mode with errors)\n                this.skipIgnored();\n                if (this.position < this.tokens.length && this.settings.errorRecovery.mode === 'strict') {\n                    this.addError({\n                        message: `Unexpected token '${this.tokens[this.position].type}'`,\n                        position: this.getCurrentPosition(),\n                        suggestions: ['Check for missing operators or delimiters'],\n                        context: this.getContext(),\n                        code: 'E001'\n                    });\n                }\n\n            } catch (error: any) {\n                this.addError({\n                    message: error.message,\n                    position: this.getCurrentPosition(),\n                    context: this.getContext(),\n                    code: 'E000'\n                });\n            }\n\n            return this.createResult();\n        }\n\n        // ════ Help ════\n\n        private parsePattern(pattern: Pattern, rule?: Rule): any {\n            if (this.depth > this.settings.maxDepth) {\n                throw new Error('Maximum parsing depth exceeded');\n            }\n\n            this.debug(`[parsePattern] Attempting to parse pattern type: ${pattern.type} at position ${this.position}, depth: ${this.depth}`);\n            this.depth++;\n\n            try {\n                this.skipIgnored(rule?.options?.ignored);\n\n                switch (pattern.type) {\n                    case 'token':\n                        return this.parseToken(pattern.name);\n\n                    case 'rule':\n                        return this.parseRule(pattern.name);\n\n                    case 'seq':\n                        return this.parseSequence(pattern.patterns, rule);\n\n                    case 'choice':\n                        return this.parseChoice(pattern.patterns, rule);\n\n                    case 'repeat':\n                        return this.parseRepeat(pattern.pattern, pattern.min || 0, pattern.max || Infinity, pattern.separator, rule);\n\n                    case 'optional':\n                        return this.parseOptional(pattern.pattern, rule);\n\n                    default:\n                        throw new Error(`Unknown pattern type: ${(pattern as any).type}`);\n                }\n            } finally {\n                this.depth--;\n            }\n        }\n\n        private parseToken(tokenName: string): Token | null {\n            if (this.position >= this.tokens.length) {\n                this.debug(`[parseToken] End of tokens reached while looking for: ${tokenName}`);\n                return null;\n            }\n\n            const token = this.tokens[this.position];\n            this.debug(`[parseToken] Looking for '${tokenName}', found '${token.type}' at position ${this.position}`);\n\n            if (token.type === tokenName) {\n                this.position++;\n                this.stats.tokensProcessed++;\n                this.skipIgnored();\n                this.debug(`[parseToken] Successfully matched token '${tokenName}'`);\n                return token;\n            }\n\n            return null;\n        }\n\n        private parseSequence(patterns: Pattern[], rule?: Rule): any {\n            this.debug(`[parseSequence] Starting sequence parse with ${patterns.length} patterns at position ${this.position}`);\n            const results: any[] = [];\n            const savedPosition = this.position;\n            const savedErrorCount = this.errors.length;\n\n            for (let i = 0; i < patterns.length; i++) {\n                this.debug(`[parseSequence] Parsing pattern ${i + 1}/${patterns.length} of type ${patterns[i].type}`);\n\n                const result = this.parsePattern(patterns[i]);\n                if (result === null) {\n                    this.debug(`[parseSequence] Pattern ${i + 1} failed at position ${this.position}`);\n\n                    // Handle sequence failure\n                    if (rule?.options?.errors) {\n                        this.handleRuleError(rule, i);\n                    }\n\n                    if (this.settings.errorRecovery.mode === 'strict') {\n                        this.position = savedPosition;\n                        return null;\n                    } else {\n                        // In resilient mode, apply recovery and return failure\n                        if (rule?.options?.recovery) {\n                            this.debug(`[parseSequence] Applying recovery strategy`);\n                            this.applyRecoveryStrategy(rule.options.recovery);\n                            this.stats.errorsRecovered++;\n                        } else {\n                            this.defaultErrorRecovery();\n                        }\n                        return null;\n                    }\n                }\n                results.push(result);\n            }\n\n            this.debug(`[parseSequence] Successfully parsed all ${patterns.length} patterns`);\n            return results;\n        }\n\n        private parseChoice(patterns: Pattern[], rule?: Rule): any {\n            const savedPosition = this.position;\n            const savedErrorCount = this.errors.length;\n\n            for (let i = 0; i < patterns.length; i++) {\n                this.position = savedPosition;\n\n                try {\n                    const result = this.parsePattern(patterns[i]);\n                    if (result !== null) {\n                        return result;\n                    }\n                } catch (error) {\n                    // Continue to next choice, but preserve position\n                    this.position = savedPosition;\n                    // Remove any errors added during this attempt in resilient mode\n                    if (this.settings.errorRecovery.mode === 'resilient') {\n                        this.errors.length = savedErrorCount;\n                    }\n                }\n            }\n\n            this.position = savedPosition;\n            return null;\n        }\n\n        private parseRepeat(pattern: Pattern, min: number = 0, max: number = Infinity, separator?: Pattern, rule?: Rule): any[] {\n            const results: any[] = [];\n            let separatorConsumed = false;\n            const loopState: LoopDetectionState = {\n                visitedPositions: new Set(),\n                iterationCount: 0,\n                lastProgress: this.position\n            };\n\n            while (results.length < max && this.position < this.tokens.length && loopState.iterationCount < this.maxIterations) {\n                const iterationStartPosition = this.position;\n                loopState.iterationCount++;\n\n                // Enhanced infinite loop detection\n                if (this.detectInfiniteLoop(loopState)) {\n                    this.debug(`[parseRepeat] Infinite loop detected at position ${this.position}`);\n                    this.addError({\n                        message: 'Infinite loop detected in repeat pattern',\n                        position: this.getCurrentPosition(),\n                        code: 'E002'\n                    });\n                    break;\n                }\n\n                // Handle separator\n                if (separator && results.length > 0) {\n                    const savedPosition = this.position;\n                    const sepResult = this.parsePattern(separator);\n                    if (sepResult === null) {\n                        this.position = savedPosition;\n                        break;\n                    }\n                    separatorConsumed = true;\n                }\n\n                const beforePatternPosition = this.position;\n                const result = this.parsePattern(pattern);\n\n                if (result === null) {\n                    this.debug(`[parseRepeat] Pattern failed at position ${this.position}, iteration ${results.length}`);\n\n                    if (separatorConsumed && this.settings.errorRecovery.mode === 'strict') {\n                        throw new Error(`Expected pattern after separator`);\n                    }\n\n                    if (this.settings.errorRecovery.mode === 'resilient' && this.position > beforePatternPosition) {\n                        separatorConsumed = false;\n                        continue;\n                    }\n\n                    break;\n                }\n\n                this.debug(`[parseRepeat] Successfully parsed iteration ${results.length + 1}`);\n                results.push(result);\n                separatorConsumed = false;\n                loopState.lastProgress = this.position;\n\n                // Additional safety check\n                if (this.position === iterationStartPosition && result !== null) {\n                    this.debug(`[parseRepeat] No progress made despite successful match, breaking`);\n                    break;\n                }\n            }\n\n            this.debug(`[parseRepeat] Completed with ${results.length} results (min: ${min})`);\n\n            // Check minimum requirement\n            if (results.length < min) {\n                if (this.settings.errorRecovery.mode === 'resilient') {\n                    this.addError({\n                        message: `Expected at least ${min} occurrences, got ${results.length}`,\n                        position: this.getCurrentPosition(),\n                        context: this.getContext(),\n                        code: 'E003'\n                    });\n                    return results;\n                } else {\n                    throw new Error(`Expected at least ${min} occurrences, got ${results.length}`);\n                }\n            }\n\n            return results;\n        }\n\n        private parseOptional(pattern: Pattern, rule?: Rule): any {\n            const savedPosition = this.position;\n            const savedErrorCount = this.errors.length;\n\n            try {\n                const result = this.parsePattern(pattern);\n                return result;\n            } catch (error) {\n                this.position = savedPosition;\n                // Remove errors added during optional parsing\n                this.errors.length = savedErrorCount;\n                return null;\n            }\n        }\n\n        private parseRule(ruleName: string): any {\n            this.debug(`[parseRule] Parsing rule: ${ruleName} at position ${this.position}`);\n\n            const rule = this.rules.get(ruleName);\n            if (!rule) {\n                throw new Error(`Rule '${ruleName}' not found`);\n            }\n\n            // Check memoization\n            if (this.settings.enableMemoization && rule.options?.memoizable !== false) {\n                const memoKey = this.getMemoKey(ruleName, this.position);\n                const memoEntry = this.memoCache.get(memoKey);\n\n                if (memoEntry && (Date.now() - memoEntry.timestamp) < 5000) { // 5 second TTL\n                    this.debug(`[parseRule] Cache hit for rule '${ruleName}' at position ${this.position}`);\n                    this.position = memoEntry.endPosition;\n                    this.cacheHits++;\n                    return memoEntry.result;\n                }\n                this.cacheMisses++;\n            }\n\n            const savedPosition = this.position;\n            const startErrorCount = this.errors.length;\n\n            try {\n                this.stats.rulesApplied++;\n                const result = this.parsePattern(rule.pattern, rule);\n\n                let finalResult = result;\n                if (result !== null && rule.options?.build) {\n                    this.debug(`[parseRule] Applying build function for rule '${ruleName}'`);\n                    finalResult = this.safeBuild(rule.options.build, result);\n                }\n\n                // Cache successful result\n                if (this.settings.enableMemoization && rule.options?.memoizable !== false && finalResult !== null) {\n                    this.cacheMemoResult(ruleName, savedPosition, finalResult, this.position, this.errors.slice(startErrorCount));\n                }\n\n                return finalResult;\n            } catch (error) {\n                if (this.settings.errorRecovery.mode === 'strict') {\n                    throw error;\n                }\n\n                // In resilient mode, apply error recovery\n                this.debug(`[parseRule] Error in rule '${ruleName}': ${(error as Error).message}`);\n                this.handleError(error as Error, rule, savedPosition);\n                return null;\n            }\n        }\n\n        // ════ More ════\n\n        private detectInfiniteLoop(state: LoopDetectionState): boolean {\n            const currentPosition = this.position;\n\n            // If we've been at this position too many times, it's likely an infinite loop\n            if (state.visitedPositions.has(currentPosition)) {\n                if (state.visitedPositions.size > 10) {\n                    return true;\n                }\n            }\n\n            state.visitedPositions.add(currentPosition);\n\n            // If we haven't made progress in a while\n            if (state.iterationCount > 100 && currentPosition === state.lastProgress) {\n                return true;\n            }\n\n            // Clear old positions occasionally\n            if (state.visitedPositions.size > 20) {\n                const positions = Array.from(state.visitedPositions);\n                state.visitedPositions.clear();\n                // Keep only recent positions\n                positions.slice(-10).forEach(pos => state.visitedPositions.add(pos));\n            }\n\n            return false;\n        }\n\n        private safeBuild(buildFn: Function, matches: any): any {\n            try {\n                const result = buildFn(Array.isArray(matches) ? matches : [matches]);\n                return result;\n            } catch (error) {\n                this.debug(`[safeBuild] Build function error: ${(error as Error).message}`);\n                this.addError({\n                    message: `Build function error: ${(error as Error).message}`,\n                    position: this.getCurrentPosition(),\n                    code: 'E004'\n                });\n                return matches; // Return original matches on build error\n            }\n        }\n\n        private getMemoKey(ruleName: string, position: number): string {\n            return `${ruleName}:${position}`;\n        }\n\n        private cacheMemoResult(ruleName: string, position: number, result: any, endPosition: number, errors: ParseError[]): void {\n            if (this.memoCache.size >= this.settings.maxCacheSize) {\n                // Simple LRU eviction - remove oldest entries\n                const oldestEntries = Array.from(this.memoCache.entries())\n                    .sort((a, b) => a[1].timestamp - b[1].timestamp)\n                    .slice(0, Math.floor(this.settings.maxCacheSize * 0.2)); // Remove 20%\n\n                oldestEntries.forEach(([key]) => this.memoCache.delete(key));\n            }\n\n            const memoKey = this.getMemoKey(ruleName, position);\n            this.memoCache.set(memoKey, {\n                result,\n                endPosition,\n                errors: [...errors],\n                timestamp: Date.now()\n            });\n        }\n\n        private handleError(error: Error, rule?: Rule, savedPosition?: number): void {\n            const pos = this.getCurrentPosition();\n            const context = this.getContext();\n            this.debug(`[handleError] Parse error: ${error.message}`);\n\n            this.addError({\n                message     : error.message,\n                position    : pos,\n                context     : context,\n                code        : 'E005'\n            });\n\n            // Apply recovery strategy to continue parsing\n            if (rule?.options?.recovery) {\n                this.debug(`[handleError] Applying recovery for rule '${rule.name}'`);\n                this.applyRecoveryStrategy(rule.options.recovery);\n                this.stats.errorsRecovered++;\n            } else {\n                this.debug(`[handleError] No recovery strategy, using default`);\n                this.defaultErrorRecovery();\n            }\n        }\n\n        private handleRuleError(rule: Rule, failedAt: number): void {\n            if (rule.options?.errors) {\n                for (const errorHandler of rule.options.errors) {\n                    if (errorHandler.condition(this, failedAt)) {\n                        this.addError({\n                            message: errorHandler.message,\n                            position: this.getCurrentPosition(),\n                            suggestions: errorHandler.suggestions,\n                            context: this.getContext(),\n                            code: errorHandler.code || 'E006',\n                            severity: errorHandler.severity || 'error'\n                        });\n                        break;\n                    }\n                }\n            }\n        }\n\n        private applyRecoveryStrategy(strategy: RecoveryStrategy): void {\n            const beforePos = this.position;\n            this.debug(`[recovery] Starting recovery at position ${beforePos}`);\n\n            switch (strategy.type) {\n                case 'panic':\n                    this.debug(`[recovery] Using panic mode recovery`);\n                    this.defaultErrorRecovery();\n                    break;\n\n                case 'skipUntil':\n                    const tokens = strategy.tokens || (strategy.token ? [strategy.token] : []);\n                    this.debug(`[recovery] Skipping until tokens: ${tokens.join(', ')}`);\n                    this.skipUntilTokens(tokens);\n                    break;\n\n                case 'insertToken':\n                    this.debug(`[recovery] Attempting token insertion recovery`);\n                    // Virtual token insertion - don't actually modify token stream\n                    break;\n\n                case 'deleteToken':\n                    this.debug(`[recovery] Attempting token deletion recovery`);\n                    if (this.position < this.tokens.length) {\n                        this.position++;\n                    }\n                    break;\n\n                default:\n                    this.defaultErrorRecovery();\n            }\n\n            this.debug(`[recovery] Recovery moved position from ${beforePos} to ${this.position}`);\n        }\n\n        private skipUntilTokens(tokens: string[]): void {\n            this.debug(`[skipUntilTokens] Looking for tokens: ${tokens.join(', ')} from position ${this.position}`);\n\n            const tokenSet = new Set(tokens);\n            let skipped = 0;\n\n            while (this.position < this.tokens.length && skipped < this.maxIterations) {\n                const currentToken = this.tokens[this.position];\n                this.debug(`[skipUntilTokens] Checking token '${currentToken.type}' at position ${this.position}`);\n\n                if (tokenSet.has(currentToken.type)) {\n                    this.debug(`[skipUntilTokens] Found sync token '${currentToken.type}' at position ${this.position}`);\n                    return;\n                }\n                this.position++;\n                skipped++;\n            }\n\n            this.debug(`[skipUntilTokens] Reached end of tokens or skip limit without finding sync token`);\n        }\n\n        private defaultErrorRecovery(): void {\n            this.debug(`[defaultErrorRecovery] Starting at position ${this.position}`);\n            const syncTokens = this.settings.errorRecovery.syncTokens;\n\n            if (syncTokens.length > 0) {\n                this.skipUntilTokens(syncTokens);\n            } else {\n                // If no sync tokens defined, skip one token\n                if (this.position < this.tokens.length) {\n                    this.debug(`[defaultErrorRecovery] No sync tokens, skipping one token`);\n                    this.position++;\n                }\n            }\n        }\n\n        private getCurrentPosition(): Position {\n            if (this.position < this.tokens.length) {\n                return this.tokens[this.position].pos;\n            }\n\n            if (this.tokens.length > 0) {\n                const lastToken = this.tokens[this.tokens.length - 1];\n                const valueLength = lastToken.value?.length || 0;\n                return {\n                    line: lastToken.pos.line,\n                    col: lastToken.pos.col + valueLength,\n                    offset: lastToken.pos.offset + valueLength\n                };\n            }\n\n            return { line: 1, col: 1, offset: 0 };\n        }\n\n        private getCurrentToken(): Token | null {\n            return this.position < this.tokens.length ? this.tokens[this.position] : null;\n        }\n\n        private getContext(): string {\n            const contextSize = 5;\n            const start = Math.max(0, this.position - contextSize);\n            const end = Math.min(this.tokens.length, this.position + contextSize);\n\n            return this.tokens.slice(start, end)\n                .map((token, idx) => {\n                    const actualIdx = start + idx;\n                    const marker = actualIdx === this.position ? '→' : ' ';\n                    return `${marker}${token.type}${token.value ? `:${token.value}` : ''}`;\n                })\n                .join(' ');\n        }\n\n        private skipIgnored(ruleIgnored?: string[]): void {\n            if (this.ignoredSet.size === 0 && (!ruleIgnored || ruleIgnored.length === 0)) {\n                return; // Early exit optimization\n            }\n\n            const combinedIgnored = ruleIgnored\n                ? new Set([...this.ignoredSet, ...ruleIgnored])\n                : this.ignoredSet;\n\n            while (this.position < this.tokens.length) {\n                const token = this.tokens[this.position];\n                if (!combinedIgnored.has(token.type)) break;\n                this.position++;\n                this.stats.tokensProcessed++;\n            }\n        }\n\n        private addError(error: ParseError): void {\n            if (this.settings.errorRecovery.maxErrors > 0 &&\n                this.errors.length >= this.settings.errorRecovery.maxErrors) {\n                return;\n            }\n\n            // Deduplicate similar errors\n            const isDuplicate = this.errors.some(existing =>\n                existing.message === error.message &&\n                existing.position.line === error.position.line &&\n                existing.position.col === error.position.col\n            );\n\n            if (!isDuplicate) {\n                this.errors.push({\n                    ...error,\n                    severity: error.severity || 'error'\n                });\n\n                if (this.settings.debug) {\n                    this.debug(`Parse Error: ${error.message} at ${error.position.line}:${error.position.col}`);\n                }\n            }\n        }\n\n        private debug(...args: any[]): void {\n            if (this.settings.debug) {\n                console.log(`[Parser]`, ...args);\n            }\n        }\n\n        // ════ Initialization and Validation ════\n\n        private validateInput(rules: Rule[], settings: ParserSettings): void {\n            if (!rules || !Array.isArray(rules) || rules.length === 0) {\n                throw new Error('Rules must be a non-empty array');\n            }\n\n            if (!settings || typeof settings !== 'object') {\n                throw new Error('Settings must be an object');\n            }\n\n            if (!settings.startRule || typeof settings.startRule !== 'string') {\n                throw new Error('Settings must specify a valid startRule');\n            }\n        }\n\n        private normalizeSettings(settings: ParserSettings): ParserSettings {\n            return {\n                startRule: settings.startRule,\n                errorRecovery: {\n                    mode: settings.errorRecovery?.mode || 'strict',\n                    maxErrors: settings.errorRecovery?.maxErrors || 10,\n                    syncTokens: settings.errorRecovery?.syncTokens || []\n                },\n                ignored: settings.ignored || ['ws'],\n                debug: settings.debug || false,\n                maxDepth: Math.max(1, settings.maxDepth || 1000),\n                enableMemoization: settings.enableMemoization !== false,\n                maxCacheSize: settings.maxCacheSize || 1000,\n                enableProfiling: settings.enableProfiling || false\n            };\n        }\n\n        private validateGrammar(): string[] {\n            const issues: string[] = [];\n            const ruleNames = new Set(Array.from(this.rules.keys()));\n\n            // Check for duplicate rule names (handled in constructor)\n            // Check for undefined rule references\n            for (const [ruleName, rule] of this.rules) {\n                const referencedRules = this.extractRuleReferences(rule.pattern);\n                for (const ref of referencedRules) {\n                    if (!ruleNames.has(ref)) {\n                        issues.push(`Rule '${ruleName}' references undefined rule '${ref}'`);\n                    }\n                }\n\n                // Check for direct left recursion\n                if (this.hasDirectLeftRecursion(rule)) {\n                    issues.push(`Rule '${ruleName}' has direct left recursion`);\n                }\n            }\n\n            // Check that start rule exists\n            if (!this.rules.has(this.settings.startRule)) {\n                issues.push(`Start rule '${this.settings.startRule}' is not defined`);\n            }\n\n            return issues;\n        }\n\n        private extractRuleReferences(pattern: Pattern): string[] {\n            const refs: string[] = [];\n\n            switch (pattern.type) {\n                case 'rule':\n                    refs.push(pattern.name);\n                    break;\n                case 'seq':\n                case 'choice':\n                    for (const p of pattern.patterns) {\n                        refs.push(...this.extractRuleReferences(p));\n                    }\n                    break;\n                case 'repeat':\n                    refs.push(...this.extractRuleReferences(pattern.pattern));\n                    if (pattern.separator) {\n                        refs.push(...this.extractRuleReferences(pattern.separator));\n                    }\n                    break;\n                case 'optional':\n                    refs.push(...this.extractRuleReferences(pattern.pattern));\n                    break;\n            }\n\n            return refs;\n        }\n\n        private hasDirectLeftRecursion(rule: Rule): boolean {\n            return this.checkLeftRecursion(rule.pattern, rule.name, new Set());\n        }\n\n        private checkLeftRecursion(pattern: Pattern, ruleName: string, visited: Set<string>): boolean {\n            if (visited.has(ruleName)) {\n                return false; // Already checking this path\n            }\n             visited.add(ruleName);\n\n            switch (pattern.type) {\n                case 'rule':\n                    return pattern.name === ruleName;\n                case 'seq':\n                    // Only first pattern matters for left recursion\n                    return pattern.patterns.length > 0 &&\n                           this.checkLeftRecursion(pattern.patterns[0], ruleName, visited);\n                case 'choice':\n                    return pattern.patterns.some((p: Pattern) => this.checkLeftRecursion(p, ruleName, visited));\n                case 'optional':\n                    // Optional patterns can contribute to left recursion\n                    return this.checkLeftRecursion(pattern.pattern, ruleName, visited);\n                default:\n                    return false;\n            }\n        }\n\n        // ════ Resource Management ════\n\n        private resetState(tokens: Token[]): void {\n            this.tokens = tokens;\n            this.position = 0;\n            this.errors = [];\n            this.ast = [];\n            this.depth = 0;\n            this.stats = {\n                tokensProcessed: 0,\n                rulesApplied: 0,\n                errorsRecovered: 0,\n                parseTimeMs: 0\n            };\n            this.cacheHits = 0;\n            this.cacheMisses = 0;\n        }\n\n        private createResult(): ParseResult {\n            this.stats.parseTimeMs = Date.now() - this.startTime;\n\n            if (this.settings.enableProfiling) {\n                this.stats.cacheHitRate = this.cacheHits + this.cacheMisses > 0\n                    ? this.cacheHits / (this.cacheHits + this.cacheMisses)\n                    : 0;\n\n                // Rough memory estimation\n                this.stats.memoryUsedKB = Math.round(\n                    (this.memoCache.size * 100 + this.nodePool.length * 50) / 1024\n                );\n            }\n\n            return {\n                ast: this.ast,\n                errors: this.errors,\n                statistics: this.settings.enableProfiling ? this.stats : undefined\n            };\n        }\n\n        /**\n         * Clears internal caches and resets parser state.\n         * Call this periodically for long-running applications.\n         */\n        public clearCaches(): void {\n            this.memoCache.clear();\n            this.nodePool = [];\n            this.debug('Caches cleared');\n        }\n\n        /**\n         * Returns current cache statistics\n         */\n        public getCacheStats(): { size: number; hitRate: number } {\n            const total = this.cacheHits + this.cacheMisses;\n            return {\n                size: this.memoCache.size,\n                hitRate: total > 0 ? this.cacheHits / total : 0\n            };\n        }\n\n        /**\n         * Disposes of the parser and frees resources.\n         * Parser cannot be reused after calling this method.\n         */\n        public dispose(): void {\n            this.clearCaches();\n            this.rules.clear();\n            this.ignoredSet.clear();\n            this.ruleSet.clear();\n\n            this.tokens         = [];\n            this.ast            = [];\n            this.errors         = [];\n            this.disposed       = true;\n\n            this.debug('Parser disposed');\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ MAIN ════════════════════════════════════════╗\n\n    /**\n     * Main parsing function - creates a parser instance and parses tokens\n     * @param tokens Array of tokens to parse\n     * @param rules Grammar rules\n     * @param settings Parser configuration\n     * @returns Parse result with AST and errors\n     */\n    export function parse(tokens: Token[], rules: Rules, settings?: Partial<ParserSettings>): ParseResult {\n        if (!tokens || tokens.length === 0) {\n            return { ast: [], errors: [] };\n        }\n\n        const defaultSettings: ParserSettings = {\n            startRule       : 'root',\n            errorRecovery   : {\n                mode        : 'strict',\n                maxErrors   : 10,\n                syncTokens  : []\n            },\n            ignored         : ['ws'], // commonly ignored whitespace\n            debug           : false,\n            maxDepth        : 1000,\n            enableMemoization: true,\n            maxCacheSize    : 1000,\n            enableProfiling : false\n        };\n\n        const mergedSettings = { ...defaultSettings, ...settings };\n\n        // Deep merge errorRecovery object\n        if (settings?.errorRecovery) {\n            mergedSettings.errorRecovery = {\n                ...defaultSettings.errorRecovery,\n                ...settings.errorRecovery\n            };\n        }\n\n        const parser = new Parser(rules, mergedSettings);\n        try {\n            return parser.parse(tokens);\n        } finally {\n            // Auto-cleanup for one-time use\n            if (!settings?.enableMemoization) {\n                parser.dispose();\n            }\n        }\n    }\n\n    /**\n     * Creates a reusable parser instance\n     * @param rules Grammar rules\n     * @param settings Parser configuration\n     * @returns Parser instance\n     */\n    export function createParser(rules: Rules, settings?: Partial<ParserSettings>): Parser {\n        const defaultSettings: ParserSettings = {\n            startRule       : 'root',\n            errorRecovery   : {\n                mode        : 'strict',\n                maxErrors   : 10,\n                syncTokens  : []\n            },\n            ignored         : ['ws'],\n            debug           : false,\n            maxDepth        : 1000,\n            enableMemoization: true,\n            maxCacheSize    : 1000,\n            enableProfiling : false\n        };\n\n        const mergedSettings = { ...defaultSettings, ...settings };\n\n        if (settings?.errorRecovery) {\n            mergedSettings.errorRecovery = {\n                ...defaultSettings.errorRecovery,\n                ...settings.errorRecovery\n            };\n        }\n\n        return new Parser(rules, mergedSettings);\n    }\n\n    /**\n     * Validates a grammar without creating a parser\n     * @param rules Grammar rules to validate\n     * @param startRule Start rule name\n     * @returns Array of validation issues (empty if valid)\n     */\n    export function validateGrammar(rules: Rules, startRule?: string): string[] {\n        try {\n            const tempSettings: ParserSettings = {\n                startRule: startRule || 'root',\n                errorRecovery: { mode: 'strict', maxErrors: 1, syncTokens: [] },\n                ignored: [],\n                debug: false,\n                maxDepth: 1000,\n                enableMemoization: false,\n                maxCacheSize: 0,\n                enableProfiling: false\n            };\n\n            const parser = new Parser(rules, tempSettings);\n            parser.dispose();\n            return [];\n        } catch (error: any) {\n            return [error.message];\n        }\n    }\n\n    /**\n     * Creates a rule with the given name, pattern, and options\n     * @param name Rule name\n     * @param pattern Rule pattern\n     * @param options Rule options\n     * @returns Rule object\n     */\n    export function createRule(name: string, pattern: Pattern, options?: Rule['options']): Rule {\n        if (!name || typeof name !== 'string') {\n            throw new Error('Rule name must be a non-empty string');\n        }\n        if (!pattern || typeof pattern !== 'object') {\n            throw new Error('Rule pattern must be an object');\n        }\n        return { name, pattern, options };\n    }\n\n    // ════ Pattern Combinators ════\n\n    /**\n     * Creates a token pattern that matches a specific token type\n     */\n    export function token(name: string): Pattern {\n        if (!name || typeof name !== 'string') {\n            throw new Error('Token name must be a non-empty string');\n        }\n        return { type: 'token', name };\n    }\n\n    /**\n     * Creates a rule reference pattern\n     */\n    export function rule(name: string): Pattern {\n        if (!name || typeof name !== 'string') {\n            throw new Error('Rule name must be a non-empty string');\n        }\n        return { type: 'rule', name };\n    }\n\n    /**\n     * Creates a sequence pattern that matches all patterns in order\n     */\n    export function seq(...patterns: Pattern[]): Pattern {\n        if (patterns.length === 0) {\n            throw new Error('Sequence must have at least one pattern');\n        }\n        return { type: 'seq', patterns };\n    }\n\n    /**\n     * Creates a choice pattern that matches any one of the given patterns\n     */\n    export function choice(...patterns: Pattern[]): Pattern {\n        if (patterns.length === 0) {\n            throw new Error('Choice must have at least one pattern');\n        }\n        return { type: 'choice', patterns };\n    }\n\n    /**\n     * Creates a repeat pattern with optional min/max bounds and separator\n     */\n    export function repeat(\n        pattern: Pattern,\n        min: number = 0,\n        max: number = Infinity,\n        separator?: Pattern\n    ): Pattern {\n        if (min < 0) {\n            throw new Error('Minimum repetition count cannot be negative');\n        }\n        if (max < min) {\n            throw new Error('Maximum repetition count cannot be less than minimum');\n        }\n        return { type: 'repeat', pattern, min, max, separator };\n    }\n\n    /**\n     * Creates an optional pattern (equivalent to repeat(pattern, 0, 1))\n     */\n    export function optional(pattern: Pattern): Pattern {\n        return { type: 'optional', pattern };\n    }\n\n    /**\n     * Creates a one-or-more repeat pattern\n     */\n    export function oneOrMore(pattern: Pattern, separator?: Pattern): Pattern {\n        return repeat(pattern, 1, Infinity, separator);\n    }\n\n    /**\n     * Creates a zero-or-more repeat pattern\n     */\n    export function zeroOrMore(pattern: Pattern, separator?: Pattern): Pattern {\n        return repeat(pattern, 0, Infinity, separator);\n    }\n\n    // ════ Error Handling ════\n\n    /**\n     * Creates an error handler for rules\n     */\n    export function error(\n        condition: ErrorHandler['condition'],\n        message: string,\n        suggestions: string[] = [],\n        code?: string,\n        severity: 'error' | 'warning' | 'info' = 'error'\n    ): ErrorHandler {\n        return { condition, message, suggestions, code, severity };\n    }\n\n    // ════ Error Recovery Strategies ════\n    export const errorRecoveryStrategies = {\n        /**\n         * Panic mode recovery - skip to synchronization tokens\n         */\n        panicMode(): RecoveryStrategy {\n            return { type: 'panic' };\n        },\n\n        /**\n         * Skip until specific tokens are found\n         */\n        skipUntil(tokens: string | string[]): RecoveryStrategy {\n            return {\n                type: 'skipUntil',\n                tokens: Array.isArray(tokens) ? tokens : [tokens]\n            };\n        },\n\n        /**\n         * Virtual token insertion (doesn't modify token stream)\n         */\n        insertToken(token: string, value?: string): RecoveryStrategy {\n            return {\n                type: 'insertToken',\n                token,\n                insertValue: value\n            };\n        },\n\n        /**\n         * Skip the current token\n         */\n        deleteToken(): RecoveryStrategy {\n            return { type: 'deleteToken' };\n        }\n    };\n\n    // ════ Context Conditions ════\n    export const contextConditions = {\n        /**\n         * Condition for when a specific token is missing\n         */\n        missingToken(tokenName: string) {\n            return (parser: Parser, failedAt: number) => {\n                return failedAt >= 0; // Simple condition - can be enhanced based on context\n            };\n        },\n\n        /**\n         * Condition for when an unexpected token is encountered\n         */\n        unexpectedToken(tokenName?: string) {\n            return (parser: Parser, failedAt: number) => {\n                return failedAt >= 0;\n            };\n        },\n\n        /**\n         * Condition for premature end of input\n         */\n        prematureEnd() {\n            return (parser: Parser, failedAt: number) => {\n                return failedAt >= 0;\n            };\n        },\n\n        /**\n         * Custom condition based on parser state\n         */\n        custom(predicate: (parser: Parser, failedAt: number) => boolean) {\n            return predicate;\n        }\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":"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","names":["rule","error","token"]}